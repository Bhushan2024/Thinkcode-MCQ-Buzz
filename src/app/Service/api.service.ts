import { environment } from 'src/environments/environment';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClient {
  /**
   * @param body (optional)
   * @return OK
   */
  getAllApplicationUser(
    body: GetAllApplicationUserReqDto | undefined,
  ): Observable<ApplicationUserResDtoListResponse>;
  /**
   * @return OK
   */
  getApplicationUserById(
    id: string,
    withDetails: boolean,
  ): Observable<ApplicationUserResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addApplicationUser(
    body: AddApplicationUserReqDto | undefined,
  ): Observable<ApplicationUserResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateApplicationUser(
    body: UpdateApplicationUserReqDto | undefined,
  ): Observable<ApplicationUserResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteApplicationUser(id: string): Observable<void>;
  /**
   * @param body (optional)
   * @return OK
   */
  register(body: RegisterDto | undefined): Observable<void>;
  /**
   * @param body (optional)
   * @return OK
   */
  login(body: LoginDto | undefined): Observable<void>;
  /**
   * @param email (optional)
   * @return OK
   */
  checkEmail(email: string | undefined): Observable<void>;
  /**
   * @param body (optional)
   * @return OK
   */
  getAllExam(body: GetAllExamReqDto | undefined): Observable<ExamResDtoListResponse>;
  /**
   * @return OK
   */
  getExamById(examId: number, withDetails: boolean): Observable<ExamResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addExam(body: AddExamReqDto | undefined): Observable<ExamResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateExam(body: UpdateExamReqDto | undefined): Observable<ExamResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteExam(examId: number): Observable<void>;
  /**
   * @return OK
   */
  getActiveExams(): Observable<ExamDtoListResponse>;
  /**
   * @param teacherId (optional)
   * @return OK
   */
  getExamsByTeacherId(teacherId: string | undefined): Observable<ExamDtoListResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  patchExam(body: ExamDto | undefined): Observable<ExamDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  getAllExamResult(
    body: GetAllExamResultReqDto | undefined,
  ): Observable<ExamResultResDtoListResponse>;
  /**
   * @return OK
   */
  getExamResultById(
    examResultId: number,
    withDetails: boolean,
  ): Observable<ExamResultResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addExamResult(body: AddExamResultReqDto | undefined): Observable<ExamResultResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateExamResult(
    body: UpdateExamResultReqDto | undefined,
  ): Observable<ExamResultResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteExamResult(examResultId: number): Observable<void>;
  /**
   * @param userExamId (optional)
   * @return OK
   */
  calculateAndCreateExamResult(
    userExamId: number | undefined,
  ): Observable<ExamResultShortDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  getAllOption(body: GetAllOptionReqDto | undefined): Observable<OptionResDtoListResponse>;
  /**
   * @return OK
   */
  getOptionById(
    optionId: number,
    withDetails: boolean,
  ): Observable<OptionResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addOption(body: AddOptionReqDto | undefined): Observable<OptionResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateOption(body: UpdateOptionReqDto | undefined): Observable<OptionResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteOption(optionId: number): Observable<void>;
  /**
   * @param body (optional)
   * @return OK
   */
  getAllQuestion(body: GetAllQuestionReqDto | undefined): Observable<QuestionResDtoListResponse>;
  /**
   * @return OK
   */
  getQuestionById(
    questionId: number,
    withDetails: boolean,
  ): Observable<QuestionResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addQuestion(body: AddQuestionReqDto | undefined): Observable<QuestionResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateQuestion(body: UpdateQuestionReqDto | undefined): Observable<QuestionResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteQuestion(questionId: number): Observable<void>;
  /**
   * @param body (optional)
   * @return OK
   */
  addQuestionWithOptions(body: QuestionDto | undefined): Observable<QuestionDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  getAllSection(body: GetAllSectionReqDto | undefined): Observable<SectionResDtoListResponse>;
  /**
   * @return OK
   */
  getSectionById(
    sectionId: number,
    withDetails: boolean,
  ): Observable<SectionResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addSection(body: AddSectionReqDto | undefined): Observable<SectionResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateSection(body: UpdateSectionReqDto | undefined): Observable<SectionResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteSection(sectionId: number): Observable<void>;
  /**
   * @param body (optional)
   * @return OK
   */
  getAllSectionResult(
    body: GetAllSectionResultReqDto | undefined,
  ): Observable<SectionResultResDtoListResponse>;
  /**
   * @return OK
   */
  getSectionResultById(
    sectionResultId: number,
    withDetails: boolean,
  ): Observable<SectionResultResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addSectionResult(
    body: AddSectionResultReqDto | undefined,
  ): Observable<SectionResultResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateSectionResult(
    body: UpdateSectionResultReqDto | undefined,
  ): Observable<SectionResultResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteSectionResult(sectionResultId: number): Observable<void>;
  /**
   * @param body (optional)
   * @return OK
   */
  getAllUserAnswer(
    body: GetAllUserAnswerReqDto | undefined,
  ): Observable<UserAnswerResDtoListResponse>;
  /**
   * @return OK
   */
  getUserAnswerById(
    userAnswerId: number,
    withDetails: boolean,
  ): Observable<UserAnswerResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addUserAnswer(body: AddUserAnswerReqDto | undefined): Observable<UserAnswerResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateUserAnswer(
    body: UpdateUserAnswerReqDto | undefined,
  ): Observable<UserAnswerResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteUserAnswer(userAnswerId: number): Observable<void>;
  /**
   * @param body (optional)
   * @return OK
   */
  getAllUserExam(body: GetAllUserExamReqDto | undefined): Observable<UserExamResDtoListResponse>;
  /**
   * @return OK
   */
  getUserExamById(
    userExamId: number,
    withDetails: boolean,
  ): Observable<UserExamResDetailDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  addUserExam(body: AddUserExamReqDto | undefined): Observable<UserExamResDtoSingleResponse>;
  /**
   * @param body (optional)
   * @return OK
   */
  updateUserExam(body: UpdateUserExamReqDto | undefined): Observable<UserExamResDtoSingleResponse>;
  /**
   * @return OK
   */
  deleteUserExam(userExamId: number): Observable<void>;
  /**
   * @param examId (optional)
   * @return OK
   */
  getUserExamsByExamId(examId: number | undefined): Observable<UserExamWithResultDtoListResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class Client implements IClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient) {
    this.http = http;
    this.baseUrl = environment.baseUrl;
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllApplicationUser(
    body: GetAllApplicationUserReqDto | undefined,
  ): Observable<ApplicationUserResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/ApplicationUser/GetAllApplicationUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllApplicationUser(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllApplicationUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApplicationUserResDtoListResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<ApplicationUserResDtoListResponse>;
        }),
      );
  }

  protected processGetAllApplicationUser(
    response: HttpResponseBase,
  ): Observable<ApplicationUserResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApplicationUserResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getApplicationUserById(
    id: string,
    withDetails: boolean,
  ): Observable<ApplicationUserResDetailDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/ApplicationUser/GetApplicationUserById/{Id}/{withDetails}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{Id}', encodeURIComponent('' + id));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetApplicationUserById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetApplicationUserById(response_ as any);
            } catch (e) {
              return _observableThrow(
                e,
              ) as any as Observable<ApplicationUserResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<ApplicationUserResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetApplicationUserById(
    response: HttpResponseBase,
  ): Observable<ApplicationUserResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApplicationUserResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addApplicationUser(
    body: AddApplicationUserReqDto | undefined,
  ): Observable<ApplicationUserResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/ApplicationUser/AddApplicationUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddApplicationUser(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddApplicationUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApplicationUserResDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<ApplicationUserResDtoSingleResponse>;
        }),
      );
  }

  protected processAddApplicationUser(
    response: HttpResponseBase,
  ): Observable<ApplicationUserResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApplicationUserResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateApplicationUser(
    body: UpdateApplicationUserReqDto | undefined,
  ): Observable<ApplicationUserResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/ApplicationUser/UpdateApplicationUser';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateApplicationUser(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateApplicationUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ApplicationUserResDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<ApplicationUserResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateApplicationUser(
    response: HttpResponseBase,
  ): Observable<ApplicationUserResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApplicationUserResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteApplicationUser(id: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/ApplicationUser/DeleteApplicationUser/{Id}';
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{Id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteApplicationUser(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteApplicationUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteApplicationUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  register(body: RegisterDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/Auth/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  login(body: LoginDto | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/Auth/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processLogin(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param email (optional)
   * @return OK
   */
  checkEmail(email: string | undefined): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/Auth/check-email?';
    if (email === null) throw new Error("The parameter 'email' cannot be null.");
    else if (email !== undefined) url_ += 'email=' + encodeURIComponent('' + email) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckEmail(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckEmail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processCheckEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllExam(body: GetAllExamReqDto | undefined): Observable<ExamResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/Exam/GetAllExam';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResDtoListResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<ExamResDtoListResponse>;
        }),
      );
  }

  protected processGetAllExam(response: HttpResponseBase): Observable<ExamResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getExamById(examId: number, withDetails: boolean): Observable<ExamResDetailDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Exam/GetExamById/{ExamId}/{withDetails}';
    if (examId === undefined || examId === null)
      throw new Error("The parameter 'examId' must be defined.");
    url_ = url_.replace('{ExamId}', encodeURIComponent('' + examId));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExamById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExamById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ExamResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetExamById(
    response: HttpResponseBase,
  ): Observable<ExamResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addExam(body: AddExamReqDto | undefined): Observable<ExamResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Exam/AddExam';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResDtoSingleResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<ExamResDtoSingleResponse>;
        }),
      );
  }

  protected processAddExam(response: HttpResponseBase): Observable<ExamResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateExam(body: UpdateExamReqDto | undefined): Observable<ExamResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Exam/UpdateExam';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResDtoSingleResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<ExamResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateExam(response: HttpResponseBase): Observable<ExamResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteExam(examId: number): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/Exam/DeleteExam/{ExamId}';
    if (examId === undefined || examId === null)
      throw new Error("The parameter 'examId' must be defined.");
    url_ = url_.replace('{ExamId}', encodeURIComponent('' + examId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteExam(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getActiveExams(): Observable<ExamDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/Exam/GetActiveExams';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetActiveExams(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetActiveExams(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamDtoListResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<ExamDtoListResponse>;
        }),
      );
  }

  protected processGetActiveExams(response: HttpResponseBase): Observable<ExamDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param teacherId (optional)
   * @return OK
   */
  getExamsByTeacherId(teacherId: string | undefined): Observable<ExamDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/Exam/GetExamsByTeacherId?';
    if (teacherId === null) throw new Error("The parameter 'teacherId' cannot be null.");
    else if (teacherId !== undefined)
      url_ += 'teacherId=' + encodeURIComponent('' + teacherId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExamsByTeacherId(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExamsByTeacherId(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamDtoListResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<ExamDtoListResponse>;
        }),
      );
  }

  protected processGetExamsByTeacherId(
    response: HttpResponseBase,
  ): Observable<ExamDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  patchExam(body: ExamDto | undefined): Observable<ExamDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Exam/PatchExam';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('patch', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPatchExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPatchExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamDtoSingleResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<ExamDtoSingleResponse>;
        }),
      );
  }

  protected processPatchExam(response: HttpResponseBase): Observable<ExamDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllExamResult(
    body: GetAllExamResultReqDto | undefined,
  ): Observable<ExamResultResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/ExamResult/GetAllExamResult';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllExamResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllExamResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResultResDtoListResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ExamResultResDtoListResponse>;
        }),
      );
  }

  protected processGetAllExamResult(
    response: HttpResponseBase,
  ): Observable<ExamResultResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResultResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getExamResultById(
    examResultId: number,
    withDetails: boolean,
  ): Observable<ExamResultResDetailDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/ExamResult/GetExamResultById/{ExamResultId}/{withDetails}';
    if (examResultId === undefined || examResultId === null)
      throw new Error("The parameter 'examResultId' must be defined.");
    url_ = url_.replace('{ExamResultId}', encodeURIComponent('' + examResultId));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExamResultById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExamResultById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResultResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<ExamResultResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetExamResultById(
    response: HttpResponseBase,
  ): Observable<ExamResultResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResultResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addExamResult(body: AddExamResultReqDto | undefined): Observable<ExamResultResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/ExamResult/AddExamResult';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddExamResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddExamResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResultResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ExamResultResDtoSingleResponse>;
        }),
      );
  }

  protected processAddExamResult(
    response: HttpResponseBase,
  ): Observable<ExamResultResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResultResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateExamResult(
    body: UpdateExamResultReqDto | undefined,
  ): Observable<ExamResultResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/ExamResult/UpdateExamResult';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateExamResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateExamResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResultResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ExamResultResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateExamResult(
    response: HttpResponseBase,
  ): Observable<ExamResultResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResultResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteExamResult(examResultId: number): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/ExamResult/DeleteExamResult/{ExamResultId}';
    if (examResultId === undefined || examResultId === null)
      throw new Error("The parameter 'examResultId' must be defined.");
    url_ = url_.replace('{ExamResultId}', encodeURIComponent('' + examResultId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteExamResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteExamResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteExamResult(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param userExamId (optional)
   * @return OK
   */
  calculateAndCreateExamResult(
    userExamId: number | undefined,
  ): Observable<ExamResultShortDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/ExamResult/CalculateAndCreateExamResult?';
    if (userExamId === null) throw new Error("The parameter 'userExamId' cannot be null.");
    else if (userExamId !== undefined)
      url_ += 'userExamId=' + encodeURIComponent('' + userExamId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCalculateAndCreateExamResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCalculateAndCreateExamResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExamResultShortDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<ExamResultShortDtoSingleResponse>;
        }),
      );
  }

  protected processCalculateAndCreateExamResult(
    response: HttpResponseBase,
  ): Observable<ExamResultShortDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExamResultShortDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllOption(body: GetAllOptionReqDto | undefined): Observable<OptionResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/Option/GetAllOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllOption(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllOption(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OptionResDtoListResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<OptionResDtoListResponse>;
        }),
      );
  }

  protected processGetAllOption(response: HttpResponseBase): Observable<OptionResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OptionResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getOptionById(
    optionId: number,
    withDetails: boolean,
  ): Observable<OptionResDetailDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Option/GetOptionById/{OptionId}/{withDetails}';
    if (optionId === undefined || optionId === null)
      throw new Error("The parameter 'optionId' must be defined.");
    url_ = url_.replace('{OptionId}', encodeURIComponent('' + optionId));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOptionById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOptionById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OptionResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<OptionResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetOptionById(
    response: HttpResponseBase,
  ): Observable<OptionResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OptionResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addOption(body: AddOptionReqDto | undefined): Observable<OptionResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Option/AddOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddOption(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddOption(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OptionResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OptionResDtoSingleResponse>;
        }),
      );
  }

  protected processAddOption(response: HttpResponseBase): Observable<OptionResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OptionResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateOption(body: UpdateOptionReqDto | undefined): Observable<OptionResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Option/UpdateOption';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateOption(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateOption(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<OptionResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<OptionResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateOption(
    response: HttpResponseBase,
  ): Observable<OptionResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = OptionResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteOption(optionId: number): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/Option/DeleteOption/{OptionId}';
    if (optionId === undefined || optionId === null)
      throw new Error("The parameter 'optionId' must be defined.");
    url_ = url_.replace('{OptionId}', encodeURIComponent('' + optionId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteOption(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteOption(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteOption(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllQuestion(body: GetAllQuestionReqDto | undefined): Observable<QuestionResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/Question/GetAllQuestion';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllQuestion(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllQuestion(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<QuestionResDtoListResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<QuestionResDtoListResponse>;
        }),
      );
  }

  protected processGetAllQuestion(
    response: HttpResponseBase,
  ): Observable<QuestionResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = QuestionResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getQuestionById(
    questionId: number,
    withDetails: boolean,
  ): Observable<QuestionResDetailDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Question/GetQuestionById/{QuestionId}/{withDetails}';
    if (questionId === undefined || questionId === null)
      throw new Error("The parameter 'questionId' must be defined.");
    url_ = url_.replace('{QuestionId}', encodeURIComponent('' + questionId));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetQuestionById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetQuestionById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<QuestionResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<QuestionResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetQuestionById(
    response: HttpResponseBase,
  ): Observable<QuestionResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = QuestionResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addQuestion(body: AddQuestionReqDto | undefined): Observable<QuestionResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Question/AddQuestion';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddQuestion(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddQuestion(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<QuestionResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<QuestionResDtoSingleResponse>;
        }),
      );
  }

  protected processAddQuestion(
    response: HttpResponseBase,
  ): Observable<QuestionResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = QuestionResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateQuestion(body: UpdateQuestionReqDto | undefined): Observable<QuestionResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Question/UpdateQuestion';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateQuestion(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateQuestion(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<QuestionResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<QuestionResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateQuestion(
    response: HttpResponseBase,
  ): Observable<QuestionResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = QuestionResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteQuestion(questionId: number): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/Question/DeleteQuestion/{QuestionId}';
    if (questionId === undefined || questionId === null)
      throw new Error("The parameter 'questionId' must be defined.");
    url_ = url_.replace('{QuestionId}', encodeURIComponent('' + questionId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteQuestion(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteQuestion(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteQuestion(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addQuestionWithOptions(body: QuestionDto | any): Observable<QuestionDtoSingleResponse> {
    let url_ = this.baseUrl + '/v1/Question/AddQuestionWithOptions';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddQuestionWithOptions(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddQuestionWithOptions(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<QuestionDtoSingleResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<QuestionDtoSingleResponse>;
        }),
      );
  }

  protected processAddQuestionWithOptions(
    response: HttpResponseBase,
  ): Observable<QuestionDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = QuestionDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllSection(body: GetAllSectionReqDto | undefined): Observable<SectionResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/Section/GetAllSection';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSection(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSection(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SectionResDtoListResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<SectionResDtoListResponse>;
        }),
      );
  }

  protected processGetAllSection(
    response: HttpResponseBase,
  ): Observable<SectionResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SectionResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getSectionById(
    sectionId: number,
    withDetails: boolean,
  ): Observable<SectionResDetailDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Section/GetSectionById/{SectionId}/{withDetails}';
    if (sectionId === undefined || sectionId === null)
      throw new Error("The parameter 'sectionId' must be defined.");
    url_ = url_.replace('{SectionId}', encodeURIComponent('' + sectionId));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSectionById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSectionById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SectionResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<SectionResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetSectionById(
    response: HttpResponseBase,
  ): Observable<SectionResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SectionResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addSection(body: AddSectionReqDto | undefined): Observable<SectionResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Section/AddSection';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddSection(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddSection(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SectionResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<SectionResDtoSingleResponse>;
        }),
      );
  }

  protected processAddSection(response: HttpResponseBase): Observable<SectionResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SectionResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateSection(body: UpdateSectionReqDto | undefined): Observable<SectionResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/Section/UpdateSection';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateSection(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateSection(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SectionResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<SectionResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateSection(
    response: HttpResponseBase,
  ): Observable<SectionResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SectionResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteSection(sectionId: number): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/Section/DeleteSection/{SectionId}';
    if (sectionId === undefined || sectionId === null)
      throw new Error("The parameter 'sectionId' must be defined.");
    url_ = url_.replace('{SectionId}', encodeURIComponent('' + sectionId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteSection(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteSection(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteSection(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllSectionResult(
    body: GetAllSectionResultReqDto | undefined,
  ): Observable<SectionResultResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/SectionResult/GetAllSectionResult';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSectionResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSectionResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SectionResultResDtoListResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<SectionResultResDtoListResponse>;
        }),
      );
  }

  protected processGetAllSectionResult(
    response: HttpResponseBase,
  ): Observable<SectionResultResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SectionResultResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getSectionResultById(
    sectionResultId: number,
    withDetails: boolean,
  ): Observable<SectionResultResDetailDtoSingleResponse> {
    let url_ =
      this.baseUrl + '/api/v1/SectionResult/GetSectionResultById/{SectionResultId}/{withDetails}';
    if (sectionResultId === undefined || sectionResultId === null)
      throw new Error("The parameter 'sectionResultId' must be defined.");
    url_ = url_.replace('{SectionResultId}', encodeURIComponent('' + sectionResultId));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSectionResultById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSectionResultById(response_ as any);
            } catch (e) {
              return _observableThrow(
                e,
              ) as any as Observable<SectionResultResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<SectionResultResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetSectionResultById(
    response: HttpResponseBase,
  ): Observable<SectionResultResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SectionResultResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addSectionResult(
    body: AddSectionResultReqDto | undefined,
  ): Observable<SectionResultResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/SectionResult/AddSectionResult';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddSectionResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddSectionResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SectionResultResDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<SectionResultResDtoSingleResponse>;
        }),
      );
  }

  protected processAddSectionResult(
    response: HttpResponseBase,
  ): Observable<SectionResultResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SectionResultResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateSectionResult(
    body: UpdateSectionResultReqDto | undefined,
  ): Observable<SectionResultResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/SectionResult/UpdateSectionResult';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateSectionResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateSectionResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SectionResultResDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<SectionResultResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateSectionResult(
    response: HttpResponseBase,
  ): Observable<SectionResultResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SectionResultResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteSectionResult(sectionResultId: number): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/SectionResult/DeleteSectionResult/{SectionResultId}';
    if (sectionResultId === undefined || sectionResultId === null)
      throw new Error("The parameter 'sectionResultId' must be defined.");
    url_ = url_.replace('{SectionResultId}', encodeURIComponent('' + sectionResultId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteSectionResult(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteSectionResult(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteSectionResult(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllUserAnswer(
    body: GetAllUserAnswerReqDto | undefined,
  ): Observable<UserAnswerResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/UserAnswer/GetAllUserAnswer';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllUserAnswer(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllUserAnswer(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserAnswerResDtoListResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserAnswerResDtoListResponse>;
        }),
      );
  }

  protected processGetAllUserAnswer(
    response: HttpResponseBase,
  ): Observable<UserAnswerResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserAnswerResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getUserAnswerById(
    userAnswerId: number,
    withDetails: boolean,
  ): Observable<UserAnswerResDetailDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/UserAnswer/GetUserAnswerById/{UserAnswerId}/{withDetails}';
    if (userAnswerId === undefined || userAnswerId === null)
      throw new Error("The parameter 'userAnswerId' must be defined.");
    url_ = url_.replace('{UserAnswerId}', encodeURIComponent('' + userAnswerId));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserAnswerById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserAnswerById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserAnswerResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<UserAnswerResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetUserAnswerById(
    response: HttpResponseBase,
  ): Observable<UserAnswerResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserAnswerResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addUserAnswer(body: AddUserAnswerReqDto | undefined): Observable<UserAnswerResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/UserAnswer/AddUserAnswer';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddUserAnswer(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddUserAnswer(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserAnswerResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserAnswerResDtoSingleResponse>;
        }),
      );
  }

  protected processAddUserAnswer(
    response: HttpResponseBase,
  ): Observable<UserAnswerResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserAnswerResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateUserAnswer(
    body: UpdateUserAnswerReqDto | undefined,
  ): Observable<UserAnswerResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/UserAnswer/UpdateUserAnswer';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateUserAnswer(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateUserAnswer(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserAnswerResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserAnswerResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateUserAnswer(
    response: HttpResponseBase,
  ): Observable<UserAnswerResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserAnswerResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteUserAnswer(userAnswerId: number): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/UserAnswer/DeleteUserAnswer/{UserAnswerId}';
    if (userAnswerId === undefined || userAnswerId === null)
      throw new Error("The parameter 'userAnswerId' must be defined.");
    url_ = url_.replace('{UserAnswerId}', encodeURIComponent('' + userAnswerId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteUserAnswer(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteUserAnswer(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteUserAnswer(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  getAllUserExam(body: GetAllUserExamReqDto | undefined): Observable<UserExamResDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/UserExam/GetAllUserExam';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllUserExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllUserExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserExamResDtoListResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserExamResDtoListResponse>;
        }),
      );
  }

  protected processGetAllUserExam(
    response: HttpResponseBase,
  ): Observable<UserExamResDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserExamResDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  getUserExamById(
    userExamId: number,
    withDetails: boolean,
  ): Observable<UserExamResDetailDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/UserExam/GetUserExamById/{UserExamId}/{withDetails}';
    if (userExamId === undefined || userExamId === null)
      throw new Error("The parameter 'userExamId' must be defined.");
    url_ = url_.replace('{UserExamId}', encodeURIComponent('' + userExamId));
    if (withDetails === undefined || withDetails === null)
      throw new Error("The parameter 'withDetails' must be defined.");
    url_ = url_.replace('{withDetails}', encodeURIComponent('' + withDetails));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserExamById(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserExamById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserExamResDetailDtoSingleResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<UserExamResDetailDtoSingleResponse>;
        }),
      );
  }

  protected processGetUserExamById(
    response: HttpResponseBase,
  ): Observable<UserExamResDetailDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserExamResDetailDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  addUserExam(body: AddUserExamReqDto | undefined): Observable<UserExamResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/UserExam/AddUserExam';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddUserExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddUserExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserExamResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserExamResDtoSingleResponse>;
        }),
      );
  }

  protected processAddUserExam(
    response: HttpResponseBase,
  ): Observable<UserExamResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserExamResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return OK
   */
  updateUserExam(body: UpdateUserExamReqDto | undefined): Observable<UserExamResDtoSingleResponse> {
    let url_ = this.baseUrl + '/api/v1/UserExam/UpdateUserExam';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json-patch+json',
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateUserExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateUserExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserExamResDtoSingleResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserExamResDtoSingleResponse>;
        }),
      );
  }

  protected processUpdateUserExam(
    response: HttpResponseBase,
  ): Observable<UserExamResDtoSingleResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserExamResDtoSingleResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return OK
   */
  deleteUserExam(userExamId: number): Observable<void> {
    let url_ = this.baseUrl + '/api/v1/UserExam/DeleteUserExam/{UserExamId}';
    if (userExamId === undefined || userExamId === null)
      throw new Error("The parameter 'userExamId' must be defined.");
    url_ = url_.replace('{UserExamId}', encodeURIComponent('' + userExamId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteUserExam(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteUserExam(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        }),
      );
  }

  protected processDeleteUserExam(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param examId (optional)
   * @return OK
   */
  getUserExamsByExamId(examId: number | undefined): Observable<UserExamWithResultDtoListResponse> {
    let url_ = this.baseUrl + '/api/v1/UserExam/GetUserExamsByExamId?';
    if (examId === null) throw new Error("The parameter 'examId' cannot be null.");
    else if (examId !== undefined) url_ += 'examId=' + encodeURIComponent('' + examId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'text/plain',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUserExamsByExamId(response_);
        }),
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUserExamsByExamId(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserExamWithResultDtoListResponse>;
            }
          } else
            return _observableThrow(
              response_,
            ) as any as Observable<UserExamWithResultDtoListResponse>;
        }),
      );
  }

  protected processGetUserExamsByExamId(
    response: HttpResponseBase,
  ): Observable<UserExamWithResultDtoListResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
          ? (response as any).error
          : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserExamWithResultDtoListResponse.fromJS(resultData200);
          return _observableOf(result200);
        }),
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers,
          );
        }),
      );
    }
    return _observableOf(null as any);
  }
}

export class AddApplicationUserReqDto implements IAddApplicationUserReqDto {
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;

  constructor(data?: IAddApplicationUserReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.passwordHash = _data['passwordHash'];
      this.securityStamp = _data['securityStamp'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      this.lockoutEnd = _data['lockoutEnd']
        ? new Date(_data['lockoutEnd'].toString())
        : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
    }
  }

  static fromJS(data: any): AddApplicationUserReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddApplicationUserReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    return data;
  }
}

export interface IAddApplicationUserReqDto {
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
}

export class AddExamReqDto implements IAddExamReqDto {
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IAddExamReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.description = _data['description'];
      this.startDate = _data['startDate']
        ? new Date(_data['startDate'].toString())
        : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
      this.duration = _data['duration'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.isRandomized = _data['isRandomized'];
      this.isActive = _data['isActive'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddExamReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddExamReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['description'] = this.description;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data['duration'] = this.duration;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['isRandomized'] = this.isRandomized;
    data['isActive'] = this.isActive;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAddExamReqDto {
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class AddExamResultReqDto implements IAddExamResultReqDto {
  userExamId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IAddExamResultReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userExamId = _data['userExamId'];
      this.totalObtainedMarks = _data['totalObtainedMarks'];
      this.resultStatus = _data['resultStatus'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddExamResultReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddExamResultReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userExamId'] = this.userExamId;
    data['totalObtainedMarks'] = this.totalObtainedMarks;
    data['resultStatus'] = this.resultStatus;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAddExamResultReqDto {
  userExamId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class AddOptionReqDto implements IAddOptionReqDto {
  questionId?: number;
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;

  constructor(data?: IAddOptionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId'];
      this.optionText = _data['optionText'];
      this.isCorrect = _data['isCorrect'];
      this.marks = _data['marks'];
    }
  }

  static fromJS(data: any): AddOptionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddOptionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['questionId'] = this.questionId;
    data['optionText'] = this.optionText;
    data['isCorrect'] = this.isCorrect;
    data['marks'] = this.marks;
    return data;
  }
}

export interface IAddOptionReqDto {
  questionId?: number;
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;
}

export class AddQuestionReqDto implements IAddQuestionReqDto {
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IAddQuestionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionId = _data['sectionId'];
      this.questionText = _data['questionText'];
      this.isMedia = _data['isMedia'];
      this.mediaType = _data['mediaType'];
      this.mediaURL = _data['mediaURL'];
      this.isMultipleChoice = _data['isMultipleChoice'];
      this.isFromQuestionBank = _data['isFromQuestionBank'];
      this.questionMaxMarks = _data['questionMaxMarks'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddQuestionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddQuestionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionId'] = this.sectionId;
    data['questionText'] = this.questionText;
    data['isMedia'] = this.isMedia;
    data['mediaType'] = this.mediaType;
    data['mediaURL'] = this.mediaURL;
    data['isMultipleChoice'] = this.isMultipleChoice;
    data['isFromQuestionBank'] = this.isFromQuestionBank;
    data['questionMaxMarks'] = this.questionMaxMarks;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAddQuestionReqDto {
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class AddSectionReqDto implements IAddSectionReqDto {
  examId?: number;
  title?: string | undefined;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  weightagePercentage?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IAddSectionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examId = _data['examId'];
      this.title = _data['title'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.weightagePercentage = _data['weightagePercentage'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddSectionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddSectionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examId'] = this.examId;
    data['title'] = this.title;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['weightagePercentage'] = this.weightagePercentage;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAddSectionReqDto {
  examId?: number;
  title?: string | undefined;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  weightagePercentage?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class AddSectionResultReqDto implements IAddSectionResultReqDto {
  sectionId?: number;
  userExamId?: number;
  questionsAttempted?: number;
  marksObtained?: number;
  resultStatus?: string | undefined;

  constructor(data?: IAddSectionResultReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionId = _data['sectionId'];
      this.userExamId = _data['userExamId'];
      this.questionsAttempted = _data['questionsAttempted'];
      this.marksObtained = _data['marksObtained'];
      this.resultStatus = _data['resultStatus'];
    }
  }

  static fromJS(data: any): AddSectionResultReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddSectionResultReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionId'] = this.sectionId;
    data['userExamId'] = this.userExamId;
    data['questionsAttempted'] = this.questionsAttempted;
    data['marksObtained'] = this.marksObtained;
    data['resultStatus'] = this.resultStatus;
    return data;
  }
}

export interface IAddSectionResultReqDto {
  sectionId?: number;
  userExamId?: number;
  questionsAttempted?: number;
  marksObtained?: number;
  resultStatus?: string | undefined;
}

export class AddUserAnswerReqDto implements IAddUserAnswerReqDto {
  questionId?: number;
  userExamId?: number;
  sectionId?: number;

  constructor(data?: IAddUserAnswerReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId'];
      this.userExamId = _data['userExamId'];
      this.sectionId = _data['sectionId'];
    }
  }

  static fromJS(data: any): AddUserAnswerReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddUserAnswerReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['questionId'] = this.questionId;
    data['userExamId'] = this.userExamId;
    data['sectionId'] = this.sectionId;
    return data;
  }
}

export interface IAddUserAnswerReqDto {
  questionId?: number;
  userExamId?: number;
  sectionId?: number;
}

export class AddUserExamReqDto implements IAddUserExamReqDto {
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IAddUserExamReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.examId = _data['examId'];
      this.startedOn = _data['startedOn']
        ? new Date(_data['startedOn'].toString())
        : <any>undefined;
      this.finishedOn = _data['finishedOn']
        ? new Date(_data['finishedOn'].toString())
        : <any>undefined;
      this.examStatus = _data['examStatus'];
      this.totalMarks = _data['totalMarks'];
      this.isAutoSubmitted = _data['isAutoSubmitted'];
      this.noOfAttempt = _data['noOfAttempt'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AddUserExamReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new AddUserExamReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['examId'] = this.examId;
    data['startedOn'] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
    data['finishedOn'] = this.finishedOn ? this.finishedOn.toISOString() : <any>undefined;
    data['examStatus'] = this.examStatus;
    data['totalMarks'] = this.totalMarks;
    data['isAutoSubmitted'] = this.isAutoSubmitted;
    data['noOfAttempt'] = this.noOfAttempt;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAddUserExamReqDto {
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class ApplicationUserResDetailDto implements IApplicationUserResDetailDto {
  userExamUsers?: UserExamResDto[] | undefined;
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;

  constructor(data?: IApplicationUserResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['userExamUsers'])) {
        this.userExamUsers = [] as any;
        for (let item of _data['userExamUsers'])
          this.userExamUsers!.push(UserExamResDto.fromJS(item));
      }
      this.id = _data['id'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.passwordHash = _data['passwordHash'];
      this.securityStamp = _data['securityStamp'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      this.lockoutEnd = _data['lockoutEnd']
        ? new Date(_data['lockoutEnd'].toString())
        : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
    }
  }

  static fromJS(data: any): ApplicationUserResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationUserResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.userExamUsers)) {
      data['userExamUsers'] = [];
      for (let item of this.userExamUsers) data['userExamUsers'].push(item.toJSON());
    }
    data['id'] = this.id;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    return data;
  }
}

export interface IApplicationUserResDetailDto {
  userExamUsers?: UserExamResDto[] | undefined;
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
}

export class ApplicationUserResDetailDtoSingleResponse
  implements IApplicationUserResDetailDtoSingleResponse
{
  data?: ApplicationUserResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IApplicationUserResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data']
        ? ApplicationUserResDetailDto.fromJS(_data['data'])
        : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ApplicationUserResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationUserResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IApplicationUserResDetailDtoSingleResponse {
  data?: ApplicationUserResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ApplicationUserResDto implements IApplicationUserResDto {
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;

  constructor(data?: IApplicationUserResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.passwordHash = _data['passwordHash'];
      this.securityStamp = _data['securityStamp'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      this.lockoutEnd = _data['lockoutEnd']
        ? new Date(_data['lockoutEnd'].toString())
        : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
    }
  }

  static fromJS(data: any): ApplicationUserResDto {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationUserResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    return data;
  }
}

export interface IApplicationUserResDto {
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
}

export class ApplicationUserResDtoListResponse implements IApplicationUserResDtoListResponse {
  data?: ApplicationUserResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IApplicationUserResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(ApplicationUserResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ApplicationUserResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationUserResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IApplicationUserResDtoListResponse {
  data?: ApplicationUserResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ApplicationUserResDtoSingleResponse implements IApplicationUserResDtoSingleResponse {
  data?: ApplicationUserResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IApplicationUserResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? ApplicationUserResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ApplicationUserResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicationUserResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IApplicationUserResDtoSingleResponse {
  data?: ApplicationUserResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class BooleanFilterExpression implements IBooleanFilterExpression {
  combineWith?: LogicalOperator;
  filters?: BooleanFilterOption[] | undefined;

  constructor(data?: IBooleanFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters']) this.filters!.push(BooleanFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BooleanFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new BooleanFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IBooleanFilterExpression {
  combineWith?: LogicalOperator;
  filters?: BooleanFilterOption[] | undefined;
}

export class BooleanFilterOption implements IBooleanFilterOption {
  value?: boolean;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IBooleanFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): BooleanFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new BooleanFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IBooleanFilterOption {
  value?: boolean;
  comparisonOperator?: ComparisonOperator;
}

export class BooleanNullableFilterExpression implements IBooleanNullableFilterExpression {
  combineWith?: LogicalOperator;
  filters?: BooleanNullableFilterOption[] | undefined;

  constructor(data?: IBooleanNullableFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters'])
          this.filters!.push(BooleanNullableFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): BooleanNullableFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new BooleanNullableFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IBooleanNullableFilterExpression {
  combineWith?: LogicalOperator;
  filters?: BooleanNullableFilterOption[] | undefined;
}

export class BooleanNullableFilterOption implements IBooleanNullableFilterOption {
  value?: boolean | undefined;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IBooleanNullableFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): BooleanNullableFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new BooleanNullableFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IBooleanNullableFilterOption {
  value?: boolean | undefined;
  comparisonOperator?: ComparisonOperator;
}

export enum ComparisonOperator {
  Equals = 'Equals',
  NotEquals = 'NotEquals',
  GreaterThan = 'GreaterThan',
  LessThan = 'LessThan',
  GreaterThanOrEqual = 'GreaterThanOrEqual',
  LessThanOrEqual = 'LessThanOrEqual',
  Contains = 'Contains',
}

export class DateTimeFilterExpression implements IDateTimeFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DateTimeFilterOption[] | undefined;

  constructor(data?: IDateTimeFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters']) this.filters!.push(DateTimeFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DateTimeFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new DateTimeFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDateTimeFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DateTimeFilterOption[] | undefined;
}

export class DateTimeFilterOption implements IDateTimeFilterOption {
  value?: Date;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IDateTimeFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'] ? new Date(_data['value'].toString()) : <any>undefined;
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): DateTimeFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new DateTimeFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value ? this.value.toISOString() : <any>undefined;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IDateTimeFilterOption {
  value?: Date;
  comparisonOperator?: ComparisonOperator;
}

export class DateTimeNullableFilterExpression implements IDateTimeNullableFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DateTimeNullableFilterOption[] | undefined;

  constructor(data?: IDateTimeNullableFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters'])
          this.filters!.push(DateTimeNullableFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DateTimeNullableFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new DateTimeNullableFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDateTimeNullableFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DateTimeNullableFilterOption[] | undefined;
}

export class DateTimeNullableFilterOption implements IDateTimeNullableFilterOption {
  value?: Date | undefined;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IDateTimeNullableFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'] ? new Date(_data['value'].toString()) : <any>undefined;
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): DateTimeNullableFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new DateTimeNullableFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value ? this.value.toISOString() : <any>undefined;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IDateTimeNullableFilterOption {
  value?: Date | undefined;
  comparisonOperator?: ComparisonOperator;
}

export class DateTimeOffsetNullableFilterExpression
  implements IDateTimeOffsetNullableFilterExpression
{
  combineWith?: LogicalOperator;
  filters?: DateTimeOffsetNullableFilterOption[] | undefined;

  constructor(data?: IDateTimeOffsetNullableFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters'])
          this.filters!.push(DateTimeOffsetNullableFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DateTimeOffsetNullableFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new DateTimeOffsetNullableFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDateTimeOffsetNullableFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DateTimeOffsetNullableFilterOption[] | undefined;
}

export class DateTimeOffsetNullableFilterOption implements IDateTimeOffsetNullableFilterOption {
  value?: Date | undefined;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IDateTimeOffsetNullableFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'] ? new Date(_data['value'].toString()) : <any>undefined;
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): DateTimeOffsetNullableFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new DateTimeOffsetNullableFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value ? this.value.toISOString() : <any>undefined;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IDateTimeOffsetNullableFilterOption {
  value?: Date | undefined;
  comparisonOperator?: ComparisonOperator;
}

export class DecimalFilterExpression implements IDecimalFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DecimalFilterOption[] | undefined;

  constructor(data?: IDecimalFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters']) this.filters!.push(DecimalFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DecimalFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new DecimalFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDecimalFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DecimalFilterOption[] | undefined;
}

export class DecimalFilterOption implements IDecimalFilterOption {
  value?: number;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IDecimalFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): DecimalFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new DecimalFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IDecimalFilterOption {
  value?: number;
  comparisonOperator?: ComparisonOperator;
}

export class DecimalNullableFilterExpression implements IDecimalNullableFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DecimalNullableFilterOption[] | undefined;

  constructor(data?: IDecimalNullableFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters'])
          this.filters!.push(DecimalNullableFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DecimalNullableFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new DecimalNullableFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDecimalNullableFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DecimalNullableFilterOption[] | undefined;
}

export class DecimalNullableFilterOption implements IDecimalNullableFilterOption {
  value?: number | undefined;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IDecimalNullableFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): DecimalNullableFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new DecimalNullableFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IDecimalNullableFilterOption {
  value?: number | undefined;
  comparisonOperator?: ComparisonOperator;
}

export class DoubleFilterExpression implements IDoubleFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DoubleFilterOption[] | undefined;

  constructor(data?: IDoubleFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters']) this.filters!.push(DoubleFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): DoubleFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new DoubleFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IDoubleFilterExpression {
  combineWith?: LogicalOperator;
  filters?: DoubleFilterOption[] | undefined;
}

export class DoubleFilterOption implements IDoubleFilterOption {
  value?: number;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IDoubleFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): DoubleFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new DoubleFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IDoubleFilterOption {
  value?: number;
  comparisonOperator?: ComparisonOperator;
}

export class ExamDto implements IExamDto {
  examId?: number;
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IExamDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examId = _data['examId'];
      this.title = _data['title'];
      this.description = _data['description'];
      this.startDate = _data['startDate']
        ? new Date(_data['startDate'].toString())
        : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
      this.duration = _data['duration'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.isRandomized = _data['isRandomized'];
      this.isActive = _data['isActive'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ExamDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExamDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examId'] = this.examId;
    data['title'] = this.title;
    data['description'] = this.description;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data['duration'] = this.duration;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['isRandomized'] = this.isRandomized;
    data['isActive'] = this.isActive;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IExamDto {
  examId?: number;
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class ExamDtoListResponse implements IExamDtoListResponse {
  data?: ExamDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(ExamDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamDtoListResponse {
  data?: ExamDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ExamDtoSingleResponse implements IExamDtoSingleResponse {
  data?: ExamDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? ExamDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamDtoSingleResponse {
  data?: ExamDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ExamResDetailDto implements IExamResDetailDto {
  sectionExams?: SectionResDto[] | undefined;
  userExamExams?: UserExamResDto[] | undefined;
  examId?: number;
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IExamResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['sectionExams'])) {
        this.sectionExams = [] as any;
        for (let item of _data['sectionExams']) this.sectionExams!.push(SectionResDto.fromJS(item));
      }
      if (Array.isArray(_data['userExamExams'])) {
        this.userExamExams = [] as any;
        for (let item of _data['userExamExams'])
          this.userExamExams!.push(UserExamResDto.fromJS(item));
      }
      this.examId = _data['examId'];
      this.title = _data['title'];
      this.description = _data['description'];
      this.startDate = _data['startDate']
        ? new Date(_data['startDate'].toString())
        : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
      this.duration = _data['duration'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.isRandomized = _data['isRandomized'];
      this.isActive = _data['isActive'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ExamResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.sectionExams)) {
      data['sectionExams'] = [];
      for (let item of this.sectionExams) data['sectionExams'].push(item.toJSON());
    }
    if (Array.isArray(this.userExamExams)) {
      data['userExamExams'] = [];
      for (let item of this.userExamExams) data['userExamExams'].push(item.toJSON());
    }
    data['examId'] = this.examId;
    data['title'] = this.title;
    data['description'] = this.description;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data['duration'] = this.duration;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['isRandomized'] = this.isRandomized;
    data['isActive'] = this.isActive;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IExamResDetailDto {
  sectionExams?: SectionResDto[] | undefined;
  userExamExams?: UserExamResDto[] | undefined;
  examId?: number;
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class ExamResDetailDtoSingleResponse implements IExamResDetailDtoSingleResponse {
  data?: ExamResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? ExamResDetailDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamResDetailDtoSingleResponse {
  data?: ExamResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ExamResDto implements IExamResDto {
  examId?: number;
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IExamResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examId = _data['examId'];
      this.title = _data['title'];
      this.description = _data['description'];
      this.startDate = _data['startDate']
        ? new Date(_data['startDate'].toString())
        : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
      this.duration = _data['duration'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.isRandomized = _data['isRandomized'];
      this.isActive = _data['isActive'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ExamResDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examId'] = this.examId;
    data['title'] = this.title;
    data['description'] = this.description;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data['duration'] = this.duration;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['isRandomized'] = this.isRandomized;
    data['isActive'] = this.isActive;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IExamResDto {
  examId?: number;
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class ExamResDtoListResponse implements IExamResDtoListResponse {
  data?: ExamResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(ExamResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamResDtoListResponse {
  data?: ExamResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ExamResDtoSingleResponse implements IExamResDtoSingleResponse {
  data?: ExamResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? ExamResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamResDtoSingleResponse {
  data?: ExamResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ExamResultDto implements IExamResultDto {
  examResultId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IExamResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examResultId = _data['examResultId'];
      this.totalObtainedMarks = _data['totalObtainedMarks'];
      this.resultStatus = _data['resultStatus'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ExamResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examResultId'] = this.examResultId;
    data['totalObtainedMarks'] = this.totalObtainedMarks;
    data['resultStatus'] = this.resultStatus;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IExamResultDto {
  examResultId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class ExamResultResDetailDto implements IExamResultResDetailDto {
  examResultUserExamIdfk?: UserExamResDto;
  examResultId?: number;
  userExamId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IExamResultResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examResultUserExamIdfk = _data['examResultUserExamIdfk']
        ? UserExamResDto.fromJS(_data['examResultUserExamIdfk'])
        : <any>undefined;
      this.examResultId = _data['examResultId'];
      this.userExamId = _data['userExamId'];
      this.totalObtainedMarks = _data['totalObtainedMarks'];
      this.resultStatus = _data['resultStatus'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ExamResultResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResultResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examResultUserExamIdfk'] = this.examResultUserExamIdfk
      ? this.examResultUserExamIdfk.toJSON()
      : <any>undefined;
    data['examResultId'] = this.examResultId;
    data['userExamId'] = this.userExamId;
    data['totalObtainedMarks'] = this.totalObtainedMarks;
    data['resultStatus'] = this.resultStatus;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IExamResultResDetailDto {
  examResultUserExamIdfk?: UserExamResDto;
  examResultId?: number;
  userExamId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class ExamResultResDetailDtoSingleResponse implements IExamResultResDetailDtoSingleResponse {
  data?: ExamResultResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamResultResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? ExamResultResDetailDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamResultResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResultResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamResultResDetailDtoSingleResponse {
  data?: ExamResultResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ExamResultResDto implements IExamResultResDto {
  examResultId?: number;
  userExamId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IExamResultResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examResultId = _data['examResultId'];
      this.userExamId = _data['userExamId'];
      this.totalObtainedMarks = _data['totalObtainedMarks'];
      this.resultStatus = _data['resultStatus'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ExamResultResDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResultResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examResultId'] = this.examResultId;
    data['userExamId'] = this.userExamId;
    data['totalObtainedMarks'] = this.totalObtainedMarks;
    data['resultStatus'] = this.resultStatus;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IExamResultResDto {
  examResultId?: number;
  userExamId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class ExamResultResDtoListResponse implements IExamResultResDtoListResponse {
  data?: ExamResultResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamResultResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(ExamResultResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamResultResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResultResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamResultResDtoListResponse {
  data?: ExamResultResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ExamResultResDtoSingleResponse implements IExamResultResDtoSingleResponse {
  data?: ExamResultResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamResultResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? ExamResultResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamResultResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResultResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamResultResDtoSingleResponse {
  data?: ExamResultResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ExamResultShortDto implements IExamResultShortDto {
  userExamId?: number;

  constructor(data?: IExamResultShortDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userExamId = _data['userExamId'];
    }
  }

  static fromJS(data: any): ExamResultShortDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResultShortDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userExamId'] = this.userExamId;
    return data;
  }
}

export interface IExamResultShortDto {
  userExamId?: number;
}

export class ExamResultShortDtoSingleResponse implements IExamResultShortDtoSingleResponse {
  data?: ExamResultShortDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IExamResultShortDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? ExamResultShortDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExamResultShortDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ExamResultShortDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExamResultShortDtoSingleResponse {
  data?: ExamResultShortDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class GetAllApplicationUserReqDto implements IGetAllApplicationUserReqDto {
  id?: StringFilterExpression;
  firstName?: StringFilterExpression;
  lastName?: StringFilterExpression;
  userName?: StringFilterExpression;
  normalizedUserName?: StringFilterExpression;
  email?: StringFilterExpression;
  normalizedEmail?: StringFilterExpression;
  emailConfirmed?: BooleanFilterExpression;
  passwordHash?: StringFilterExpression;
  securityStamp?: StringFilterExpression;
  concurrencyStamp?: StringFilterExpression;
  phoneNumber?: StringFilterExpression;
  phoneNumberConfirmed?: BooleanFilterExpression;
  twoFactorEnabled?: BooleanFilterExpression;
  lockoutEnd?: DateTimeOffsetNullableFilterExpression;
  lockoutEnabled?: BooleanFilterExpression;
  accessFailedCount?: Int32FilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllApplicationUserReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'] ? StringFilterExpression.fromJS(_data['id']) : <any>undefined;
      this.firstName = _data['firstName']
        ? StringFilterExpression.fromJS(_data['firstName'])
        : <any>undefined;
      this.lastName = _data['lastName']
        ? StringFilterExpression.fromJS(_data['lastName'])
        : <any>undefined;
      this.userName = _data['userName']
        ? StringFilterExpression.fromJS(_data['userName'])
        : <any>undefined;
      this.normalizedUserName = _data['normalizedUserName']
        ? StringFilterExpression.fromJS(_data['normalizedUserName'])
        : <any>undefined;
      this.email = _data['email'] ? StringFilterExpression.fromJS(_data['email']) : <any>undefined;
      this.normalizedEmail = _data['normalizedEmail']
        ? StringFilterExpression.fromJS(_data['normalizedEmail'])
        : <any>undefined;
      this.emailConfirmed = _data['emailConfirmed']
        ? BooleanFilterExpression.fromJS(_data['emailConfirmed'])
        : <any>undefined;
      this.passwordHash = _data['passwordHash']
        ? StringFilterExpression.fromJS(_data['passwordHash'])
        : <any>undefined;
      this.securityStamp = _data['securityStamp']
        ? StringFilterExpression.fromJS(_data['securityStamp'])
        : <any>undefined;
      this.concurrencyStamp = _data['concurrencyStamp']
        ? StringFilterExpression.fromJS(_data['concurrencyStamp'])
        : <any>undefined;
      this.phoneNumber = _data['phoneNumber']
        ? StringFilterExpression.fromJS(_data['phoneNumber'])
        : <any>undefined;
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed']
        ? BooleanFilterExpression.fromJS(_data['phoneNumberConfirmed'])
        : <any>undefined;
      this.twoFactorEnabled = _data['twoFactorEnabled']
        ? BooleanFilterExpression.fromJS(_data['twoFactorEnabled'])
        : <any>undefined;
      this.lockoutEnd = _data['lockoutEnd']
        ? DateTimeOffsetNullableFilterExpression.fromJS(_data['lockoutEnd'])
        : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled']
        ? BooleanFilterExpression.fromJS(_data['lockoutEnabled'])
        : <any>undefined;
      this.accessFailedCount = _data['accessFailedCount']
        ? Int32FilterExpression.fromJS(_data['accessFailedCount'])
        : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllApplicationUserReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllApplicationUserReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id ? this.id.toJSON() : <any>undefined;
    data['firstName'] = this.firstName ? this.firstName.toJSON() : <any>undefined;
    data['lastName'] = this.lastName ? this.lastName.toJSON() : <any>undefined;
    data['userName'] = this.userName ? this.userName.toJSON() : <any>undefined;
    data['normalizedUserName'] = this.normalizedUserName
      ? this.normalizedUserName.toJSON()
      : <any>undefined;
    data['email'] = this.email ? this.email.toJSON() : <any>undefined;
    data['normalizedEmail'] = this.normalizedEmail ? this.normalizedEmail.toJSON() : <any>undefined;
    data['emailConfirmed'] = this.emailConfirmed ? this.emailConfirmed.toJSON() : <any>undefined;
    data['passwordHash'] = this.passwordHash ? this.passwordHash.toJSON() : <any>undefined;
    data['securityStamp'] = this.securityStamp ? this.securityStamp.toJSON() : <any>undefined;
    data['concurrencyStamp'] = this.concurrencyStamp
      ? this.concurrencyStamp.toJSON()
      : <any>undefined;
    data['phoneNumber'] = this.phoneNumber ? this.phoneNumber.toJSON() : <any>undefined;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed
      ? this.phoneNumberConfirmed.toJSON()
      : <any>undefined;
    data['twoFactorEnabled'] = this.twoFactorEnabled
      ? this.twoFactorEnabled.toJSON()
      : <any>undefined;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toJSON() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled ? this.lockoutEnabled.toJSON() : <any>undefined;
    data['accessFailedCount'] = this.accessFailedCount
      ? this.accessFailedCount.toJSON()
      : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllApplicationUserReqDto {
  id?: StringFilterExpression;
  firstName?: StringFilterExpression;
  lastName?: StringFilterExpression;
  userName?: StringFilterExpression;
  normalizedUserName?: StringFilterExpression;
  email?: StringFilterExpression;
  normalizedEmail?: StringFilterExpression;
  emailConfirmed?: BooleanFilterExpression;
  passwordHash?: StringFilterExpression;
  securityStamp?: StringFilterExpression;
  concurrencyStamp?: StringFilterExpression;
  phoneNumber?: StringFilterExpression;
  phoneNumberConfirmed?: BooleanFilterExpression;
  twoFactorEnabled?: BooleanFilterExpression;
  lockoutEnd?: DateTimeOffsetNullableFilterExpression;
  lockoutEnabled?: BooleanFilterExpression;
  accessFailedCount?: Int32FilterExpression;
  options?: Pagination;
}

export class GetAllExamReqDto implements IGetAllExamReqDto {
  examId?: Int32FilterExpression;
  title?: StringFilterExpression;
  description?: StringFilterExpression;
  startDate?: DateTimeFilterExpression;
  endDate?: DateTimeFilterExpression;
  duration?: DoubleFilterExpression;
  totalQuestions?: Int32FilterExpression;
  totalMarks?: DecimalFilterExpression;
  passingMarks?: DecimalFilterExpression;
  isRandomized?: BooleanFilterExpression;
  isActive?: BooleanFilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllExamReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examId = _data['examId']
        ? Int32FilterExpression.fromJS(_data['examId'])
        : <any>undefined;
      this.title = _data['title'] ? StringFilterExpression.fromJS(_data['title']) : <any>undefined;
      this.description = _data['description']
        ? StringFilterExpression.fromJS(_data['description'])
        : <any>undefined;
      this.startDate = _data['startDate']
        ? DateTimeFilterExpression.fromJS(_data['startDate'])
        : <any>undefined;
      this.endDate = _data['endDate']
        ? DateTimeFilterExpression.fromJS(_data['endDate'])
        : <any>undefined;
      this.duration = _data['duration']
        ? DoubleFilterExpression.fromJS(_data['duration'])
        : <any>undefined;
      this.totalQuestions = _data['totalQuestions']
        ? Int32FilterExpression.fromJS(_data['totalQuestions'])
        : <any>undefined;
      this.totalMarks = _data['totalMarks']
        ? DecimalFilterExpression.fromJS(_data['totalMarks'])
        : <any>undefined;
      this.passingMarks = _data['passingMarks']
        ? DecimalFilterExpression.fromJS(_data['passingMarks'])
        : <any>undefined;
      this.isRandomized = _data['isRandomized']
        ? BooleanFilterExpression.fromJS(_data['isRandomized'])
        : <any>undefined;
      this.isActive = _data['isActive']
        ? BooleanFilterExpression.fromJS(_data['isActive'])
        : <any>undefined;
      this.createdBy = _data['createdBy']
        ? StringFilterExpression.fromJS(_data['createdBy'])
        : <any>undefined;
      this.createdOn = _data['createdOn']
        ? DateTimeFilterExpression.fromJS(_data['createdOn'])
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? DateTimeFilterExpression.fromJS(_data['updatedOn'])
        : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllExamReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllExamReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examId'] = this.examId ? this.examId.toJSON() : <any>undefined;
    data['title'] = this.title ? this.title.toJSON() : <any>undefined;
    data['description'] = this.description ? this.description.toJSON() : <any>undefined;
    data['startDate'] = this.startDate ? this.startDate.toJSON() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toJSON() : <any>undefined;
    data['duration'] = this.duration ? this.duration.toJSON() : <any>undefined;
    data['totalQuestions'] = this.totalQuestions ? this.totalQuestions.toJSON() : <any>undefined;
    data['totalMarks'] = this.totalMarks ? this.totalMarks.toJSON() : <any>undefined;
    data['passingMarks'] = this.passingMarks ? this.passingMarks.toJSON() : <any>undefined;
    data['isRandomized'] = this.isRandomized ? this.isRandomized.toJSON() : <any>undefined;
    data['isActive'] = this.isActive ? this.isActive.toJSON() : <any>undefined;
    data['createdBy'] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
    data['createdOn'] = this.createdOn ? this.createdOn.toJSON() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toJSON() : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllExamReqDto {
  examId?: Int32FilterExpression;
  title?: StringFilterExpression;
  description?: StringFilterExpression;
  startDate?: DateTimeFilterExpression;
  endDate?: DateTimeFilterExpression;
  duration?: DoubleFilterExpression;
  totalQuestions?: Int32FilterExpression;
  totalMarks?: DecimalFilterExpression;
  passingMarks?: DecimalFilterExpression;
  isRandomized?: BooleanFilterExpression;
  isActive?: BooleanFilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;
}

export class GetAllExamResultReqDto implements IGetAllExamResultReqDto {
  examResultId?: Int32FilterExpression;
  userExamId?: Int32FilterExpression;
  totalObtainedMarks?: DecimalFilterExpression;
  resultStatus?: StringFilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllExamResultReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examResultId = _data['examResultId']
        ? Int32FilterExpression.fromJS(_data['examResultId'])
        : <any>undefined;
      this.userExamId = _data['userExamId']
        ? Int32FilterExpression.fromJS(_data['userExamId'])
        : <any>undefined;
      this.totalObtainedMarks = _data['totalObtainedMarks']
        ? DecimalFilterExpression.fromJS(_data['totalObtainedMarks'])
        : <any>undefined;
      this.resultStatus = _data['resultStatus']
        ? StringFilterExpression.fromJS(_data['resultStatus'])
        : <any>undefined;
      this.createdBy = _data['createdBy']
        ? StringFilterExpression.fromJS(_data['createdBy'])
        : <any>undefined;
      this.createdOn = _data['createdOn']
        ? DateTimeFilterExpression.fromJS(_data['createdOn'])
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? DateTimeFilterExpression.fromJS(_data['updatedOn'])
        : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllExamResultReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllExamResultReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examResultId'] = this.examResultId ? this.examResultId.toJSON() : <any>undefined;
    data['userExamId'] = this.userExamId ? this.userExamId.toJSON() : <any>undefined;
    data['totalObtainedMarks'] = this.totalObtainedMarks
      ? this.totalObtainedMarks.toJSON()
      : <any>undefined;
    data['resultStatus'] = this.resultStatus ? this.resultStatus.toJSON() : <any>undefined;
    data['createdBy'] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
    data['createdOn'] = this.createdOn ? this.createdOn.toJSON() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toJSON() : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllExamResultReqDto {
  examResultId?: Int32FilterExpression;
  userExamId?: Int32FilterExpression;
  totalObtainedMarks?: DecimalFilterExpression;
  resultStatus?: StringFilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;
}

export class GetAllOptionReqDto implements IGetAllOptionReqDto {
  optionId?: Int32FilterExpression;
  questionId?: Int32FilterExpression;
  optionText?: StringFilterExpression;
  isCorrect?: BooleanFilterExpression;
  marks?: DecimalFilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllOptionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.optionId = _data['optionId']
        ? Int32FilterExpression.fromJS(_data['optionId'])
        : <any>undefined;
      this.questionId = _data['questionId']
        ? Int32FilterExpression.fromJS(_data['questionId'])
        : <any>undefined;
      this.optionText = _data['optionText']
        ? StringFilterExpression.fromJS(_data['optionText'])
        : <any>undefined;
      this.isCorrect = _data['isCorrect']
        ? BooleanFilterExpression.fromJS(_data['isCorrect'])
        : <any>undefined;
      this.marks = _data['marks'] ? DecimalFilterExpression.fromJS(_data['marks']) : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllOptionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllOptionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['optionId'] = this.optionId ? this.optionId.toJSON() : <any>undefined;
    data['questionId'] = this.questionId ? this.questionId.toJSON() : <any>undefined;
    data['optionText'] = this.optionText ? this.optionText.toJSON() : <any>undefined;
    data['isCorrect'] = this.isCorrect ? this.isCorrect.toJSON() : <any>undefined;
    data['marks'] = this.marks ? this.marks.toJSON() : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllOptionReqDto {
  optionId?: Int32FilterExpression;
  questionId?: Int32FilterExpression;
  optionText?: StringFilterExpression;
  isCorrect?: BooleanFilterExpression;
  marks?: DecimalFilterExpression;
  options?: Pagination;
}

export class GetAllQuestionReqDto implements IGetAllQuestionReqDto {
  questionId?: Int32FilterExpression;
  sectionId?: Int32FilterExpression;
  questionText?: StringFilterExpression;
  isMedia?: BooleanFilterExpression;
  mediaType?: StringFilterExpression;
  mediaURL?: StringFilterExpression;
  isMultipleChoice?: BooleanFilterExpression;
  isFromQuestionBank?: BooleanFilterExpression;
  questionMaxMarks?: DecimalFilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllQuestionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId']
        ? Int32FilterExpression.fromJS(_data['questionId'])
        : <any>undefined;
      this.sectionId = _data['sectionId']
        ? Int32FilterExpression.fromJS(_data['sectionId'])
        : <any>undefined;
      this.questionText = _data['questionText']
        ? StringFilterExpression.fromJS(_data['questionText'])
        : <any>undefined;
      this.isMedia = _data['isMedia']
        ? BooleanFilterExpression.fromJS(_data['isMedia'])
        : <any>undefined;
      this.mediaType = _data['mediaType']
        ? StringFilterExpression.fromJS(_data['mediaType'])
        : <any>undefined;
      this.mediaURL = _data['mediaURL']
        ? StringFilterExpression.fromJS(_data['mediaURL'])
        : <any>undefined;
      this.isMultipleChoice = _data['isMultipleChoice']
        ? BooleanFilterExpression.fromJS(_data['isMultipleChoice'])
        : <any>undefined;
      this.isFromQuestionBank = _data['isFromQuestionBank']
        ? BooleanFilterExpression.fromJS(_data['isFromQuestionBank'])
        : <any>undefined;
      this.questionMaxMarks = _data['questionMaxMarks']
        ? DecimalFilterExpression.fromJS(_data['questionMaxMarks'])
        : <any>undefined;
      this.createdBy = _data['createdBy']
        ? StringFilterExpression.fromJS(_data['createdBy'])
        : <any>undefined;
      this.createdOn = _data['createdOn']
        ? DateTimeFilterExpression.fromJS(_data['createdOn'])
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? DateTimeFilterExpression.fromJS(_data['updatedOn'])
        : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllQuestionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllQuestionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['questionId'] = this.questionId ? this.questionId.toJSON() : <any>undefined;
    data['sectionId'] = this.sectionId ? this.sectionId.toJSON() : <any>undefined;
    data['questionText'] = this.questionText ? this.questionText.toJSON() : <any>undefined;
    data['isMedia'] = this.isMedia ? this.isMedia.toJSON() : <any>undefined;
    data['mediaType'] = this.mediaType ? this.mediaType.toJSON() : <any>undefined;
    data['mediaURL'] = this.mediaURL ? this.mediaURL.toJSON() : <any>undefined;
    data['isMultipleChoice'] = this.isMultipleChoice
      ? this.isMultipleChoice.toJSON()
      : <any>undefined;
    data['isFromQuestionBank'] = this.isFromQuestionBank
      ? this.isFromQuestionBank.toJSON()
      : <any>undefined;
    data['questionMaxMarks'] = this.questionMaxMarks
      ? this.questionMaxMarks.toJSON()
      : <any>undefined;
    data['createdBy'] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
    data['createdOn'] = this.createdOn ? this.createdOn.toJSON() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toJSON() : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllQuestionReqDto {
  questionId?: Int32FilterExpression;
  sectionId?: Int32FilterExpression;
  questionText?: StringFilterExpression;
  isMedia?: BooleanFilterExpression;
  mediaType?: StringFilterExpression;
  mediaURL?: StringFilterExpression;
  isMultipleChoice?: BooleanFilterExpression;
  isFromQuestionBank?: BooleanFilterExpression;
  questionMaxMarks?: DecimalFilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;
}

export class GetAllSectionReqDto implements IGetAllSectionReqDto {
  sectionId?: Int32FilterExpression;
  examId?: Int32FilterExpression;
  title?: StringFilterExpression;
  totalQuestions?: Int32FilterExpression;
  totalMarks?: DecimalFilterExpression;
  passingMarks?: DecimalFilterExpression;
  weightagePercentage?: DecimalFilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllSectionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionId = _data['sectionId']
        ? Int32FilterExpression.fromJS(_data['sectionId'])
        : <any>undefined;
      this.examId = _data['examId']
        ? Int32FilterExpression.fromJS(_data['examId'])
        : <any>undefined;
      this.title = _data['title'] ? StringFilterExpression.fromJS(_data['title']) : <any>undefined;
      this.totalQuestions = _data['totalQuestions']
        ? Int32FilterExpression.fromJS(_data['totalQuestions'])
        : <any>undefined;
      this.totalMarks = _data['totalMarks']
        ? DecimalFilterExpression.fromJS(_data['totalMarks'])
        : <any>undefined;
      this.passingMarks = _data['passingMarks']
        ? DecimalFilterExpression.fromJS(_data['passingMarks'])
        : <any>undefined;
      this.weightagePercentage = _data['weightagePercentage']
        ? DecimalFilterExpression.fromJS(_data['weightagePercentage'])
        : <any>undefined;
      this.createdBy = _data['createdBy']
        ? StringFilterExpression.fromJS(_data['createdBy'])
        : <any>undefined;
      this.createdOn = _data['createdOn']
        ? DateTimeFilterExpression.fromJS(_data['createdOn'])
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? DateTimeFilterExpression.fromJS(_data['updatedOn'])
        : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllSectionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllSectionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionId'] = this.sectionId ? this.sectionId.toJSON() : <any>undefined;
    data['examId'] = this.examId ? this.examId.toJSON() : <any>undefined;
    data['title'] = this.title ? this.title.toJSON() : <any>undefined;
    data['totalQuestions'] = this.totalQuestions ? this.totalQuestions.toJSON() : <any>undefined;
    data['totalMarks'] = this.totalMarks ? this.totalMarks.toJSON() : <any>undefined;
    data['passingMarks'] = this.passingMarks ? this.passingMarks.toJSON() : <any>undefined;
    data['weightagePercentage'] = this.weightagePercentage
      ? this.weightagePercentage.toJSON()
      : <any>undefined;
    data['createdBy'] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
    data['createdOn'] = this.createdOn ? this.createdOn.toJSON() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toJSON() : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllSectionReqDto {
  sectionId?: Int32FilterExpression;
  examId?: Int32FilterExpression;
  title?: StringFilterExpression;
  totalQuestions?: Int32FilterExpression;
  totalMarks?: DecimalFilterExpression;
  passingMarks?: DecimalFilterExpression;
  weightagePercentage?: DecimalFilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;
}

export class GetAllSectionResultReqDto implements IGetAllSectionResultReqDto {
  sectionResultId?: Int32FilterExpression;
  sectionId?: Int32FilterExpression;
  userExamId?: Int32FilterExpression;
  questionsAttempted?: Int32FilterExpression;
  marksObtained?: DecimalFilterExpression;
  resultStatus?: StringFilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllSectionResultReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionResultId = _data['sectionResultId']
        ? Int32FilterExpression.fromJS(_data['sectionResultId'])
        : <any>undefined;
      this.sectionId = _data['sectionId']
        ? Int32FilterExpression.fromJS(_data['sectionId'])
        : <any>undefined;
      this.userExamId = _data['userExamId']
        ? Int32FilterExpression.fromJS(_data['userExamId'])
        : <any>undefined;
      this.questionsAttempted = _data['questionsAttempted']
        ? Int32FilterExpression.fromJS(_data['questionsAttempted'])
        : <any>undefined;
      this.marksObtained = _data['marksObtained']
        ? DecimalFilterExpression.fromJS(_data['marksObtained'])
        : <any>undefined;
      this.resultStatus = _data['resultStatus']
        ? StringFilterExpression.fromJS(_data['resultStatus'])
        : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllSectionResultReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllSectionResultReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionResultId'] = this.sectionResultId ? this.sectionResultId.toJSON() : <any>undefined;
    data['sectionId'] = this.sectionId ? this.sectionId.toJSON() : <any>undefined;
    data['userExamId'] = this.userExamId ? this.userExamId.toJSON() : <any>undefined;
    data['questionsAttempted'] = this.questionsAttempted
      ? this.questionsAttempted.toJSON()
      : <any>undefined;
    data['marksObtained'] = this.marksObtained ? this.marksObtained.toJSON() : <any>undefined;
    data['resultStatus'] = this.resultStatus ? this.resultStatus.toJSON() : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllSectionResultReqDto {
  sectionResultId?: Int32FilterExpression;
  sectionId?: Int32FilterExpression;
  userExamId?: Int32FilterExpression;
  questionsAttempted?: Int32FilterExpression;
  marksObtained?: DecimalFilterExpression;
  resultStatus?: StringFilterExpression;
  options?: Pagination;
}

export class GetAllUserAnswerReqDto implements IGetAllUserAnswerReqDto {
  userAnswerId?: Int32FilterExpression;
  questionId?: Int32FilterExpression;
  userExamId?: Int32FilterExpression;
  sectionId?: Int32FilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllUserAnswerReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userAnswerId = _data['userAnswerId']
        ? Int32FilterExpression.fromJS(_data['userAnswerId'])
        : <any>undefined;
      this.questionId = _data['questionId']
        ? Int32FilterExpression.fromJS(_data['questionId'])
        : <any>undefined;
      this.userExamId = _data['userExamId']
        ? Int32FilterExpression.fromJS(_data['userExamId'])
        : <any>undefined;
      this.sectionId = _data['sectionId']
        ? Int32FilterExpression.fromJS(_data['sectionId'])
        : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllUserAnswerReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllUserAnswerReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userAnswerId'] = this.userAnswerId ? this.userAnswerId.toJSON() : <any>undefined;
    data['questionId'] = this.questionId ? this.questionId.toJSON() : <any>undefined;
    data['userExamId'] = this.userExamId ? this.userExamId.toJSON() : <any>undefined;
    data['sectionId'] = this.sectionId ? this.sectionId.toJSON() : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllUserAnswerReqDto {
  userAnswerId?: Int32FilterExpression;
  questionId?: Int32FilterExpression;
  userExamId?: Int32FilterExpression;
  sectionId?: Int32FilterExpression;
  options?: Pagination;
}

export class GetAllUserExamReqDto implements IGetAllUserExamReqDto {
  userExamId?: Int32FilterExpression;
  userId?: StringFilterExpression;
  examId?: Int32FilterExpression;
  startedOn?: DateTimeFilterExpression;
  finishedOn?: DateTimeNullableFilterExpression;
  examStatus?: StringFilterExpression;
  totalMarks?: DecimalNullableFilterExpression;
  isAutoSubmitted?: BooleanNullableFilterExpression;
  noOfAttempt?: Int32FilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;

  constructor(data?: IGetAllUserExamReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userExamId = _data['userExamId']
        ? Int32FilterExpression.fromJS(_data['userExamId'])
        : <any>undefined;
      this.userId = _data['userId']
        ? StringFilterExpression.fromJS(_data['userId'])
        : <any>undefined;
      this.examId = _data['examId']
        ? Int32FilterExpression.fromJS(_data['examId'])
        : <any>undefined;
      this.startedOn = _data['startedOn']
        ? DateTimeFilterExpression.fromJS(_data['startedOn'])
        : <any>undefined;
      this.finishedOn = _data['finishedOn']
        ? DateTimeNullableFilterExpression.fromJS(_data['finishedOn'])
        : <any>undefined;
      this.examStatus = _data['examStatus']
        ? StringFilterExpression.fromJS(_data['examStatus'])
        : <any>undefined;
      this.totalMarks = _data['totalMarks']
        ? DecimalNullableFilterExpression.fromJS(_data['totalMarks'])
        : <any>undefined;
      this.isAutoSubmitted = _data['isAutoSubmitted']
        ? BooleanNullableFilterExpression.fromJS(_data['isAutoSubmitted'])
        : <any>undefined;
      this.noOfAttempt = _data['noOfAttempt']
        ? Int32FilterExpression.fromJS(_data['noOfAttempt'])
        : <any>undefined;
      this.createdBy = _data['createdBy']
        ? StringFilterExpression.fromJS(_data['createdBy'])
        : <any>undefined;
      this.createdOn = _data['createdOn']
        ? DateTimeFilterExpression.fromJS(_data['createdOn'])
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? DateTimeFilterExpression.fromJS(_data['updatedOn'])
        : <any>undefined;
      this.options = _data['options'] ? Pagination.fromJS(_data['options']) : <any>undefined;
    }
  }

  static fromJS(data: any): GetAllUserExamReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new GetAllUserExamReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userExamId'] = this.userExamId ? this.userExamId.toJSON() : <any>undefined;
    data['userId'] = this.userId ? this.userId.toJSON() : <any>undefined;
    data['examId'] = this.examId ? this.examId.toJSON() : <any>undefined;
    data['startedOn'] = this.startedOn ? this.startedOn.toJSON() : <any>undefined;
    data['finishedOn'] = this.finishedOn ? this.finishedOn.toJSON() : <any>undefined;
    data['examStatus'] = this.examStatus ? this.examStatus.toJSON() : <any>undefined;
    data['totalMarks'] = this.totalMarks ? this.totalMarks.toJSON() : <any>undefined;
    data['isAutoSubmitted'] = this.isAutoSubmitted ? this.isAutoSubmitted.toJSON() : <any>undefined;
    data['noOfAttempt'] = this.noOfAttempt ? this.noOfAttempt.toJSON() : <any>undefined;
    data['createdBy'] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
    data['createdOn'] = this.createdOn ? this.createdOn.toJSON() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toJSON() : <any>undefined;
    data['options'] = this.options ? this.options.toJSON() : <any>undefined;
    return data;
  }
}

export interface IGetAllUserExamReqDto {
  userExamId?: Int32FilterExpression;
  userId?: StringFilterExpression;
  examId?: Int32FilterExpression;
  startedOn?: DateTimeFilterExpression;
  finishedOn?: DateTimeNullableFilterExpression;
  examStatus?: StringFilterExpression;
  totalMarks?: DecimalNullableFilterExpression;
  isAutoSubmitted?: BooleanNullableFilterExpression;
  noOfAttempt?: Int32FilterExpression;
  createdBy?: StringFilterExpression;
  createdOn?: DateTimeFilterExpression;
  updatedOn?: DateTimeFilterExpression;
  options?: Pagination;
}

export enum HttpStatusCode {
  _100 = 100,
  _101 = 101,
  _102 = 102,
  _103 = 103,
  _200 = 200,
  _201 = 201,
  _202 = 202,
  _203 = 203,
  _204 = 204,
  _205 = 205,
  _206 = 206,
  _207 = 207,
  _208 = 208,
  _226 = 226,
  _300 = 300,
  _301 = 301,
  _302 = 302,
  _303 = 303,
  _304 = 304,
  _305 = 305,
  _306 = 306,
  _307 = 307,
  _308 = 308,
  _400 = 400,
  _401 = 401,
  _402 = 402,
  _403 = 403,
  _404 = 404,
  _405 = 405,
  _406 = 406,
  _407 = 407,
  _408 = 408,
  _409 = 409,
  _410 = 410,
  _411 = 411,
  _412 = 412,
  _413 = 413,
  _414 = 414,
  _415 = 415,
  _416 = 416,
  _417 = 417,
  _421 = 421,
  _422 = 422,
  _423 = 423,
  _424 = 424,
  _426 = 426,
  _428 = 428,
  _429 = 429,
  _431 = 431,
  _451 = 451,
  _500 = 500,
  _501 = 501,
  _502 = 502,
  _503 = 503,
  _504 = 504,
  _505 = 505,
  _506 = 506,
  _507 = 507,
  _508 = 508,
  _510 = 510,
  _511 = 511,
}

export class Int32FilterExpression implements IInt32FilterExpression {
  combineWith?: LogicalOperator;
  filters?: Int32FilterOption[] | undefined;

  constructor(data?: IInt32FilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters']) this.filters!.push(Int32FilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Int32FilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new Int32FilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IInt32FilterExpression {
  combineWith?: LogicalOperator;
  filters?: Int32FilterOption[] | undefined;
}

export class Int32FilterOption implements IInt32FilterOption {
  value?: number;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IInt32FilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): Int32FilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new Int32FilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IInt32FilterOption {
  value?: number;
  comparisonOperator?: ComparisonOperator;
}

export enum LogicalOperator {
  And = 'And',
  Or = 'Or',
}

export class LoginDto implements ILoginDto {
  email!: string;
  password!: string;

  constructor(data?: ILoginDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LoginDto {
    data = typeof data === 'object' ? data : {};
    let result = new LoginDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginDto {
  email: string;
  password: string;
}

export class OptionDto implements IOptionDto {
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;

  constructor(data?: IOptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.optionText = _data['optionText'];
      this.isCorrect = _data['isCorrect'];
      this.marks = _data['marks'];
    }
  }

  static fromJS(data: any): OptionDto {
    data = typeof data === 'object' ? data : {};
    let result = new OptionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['optionText'] = this.optionText;
    data['isCorrect'] = this.isCorrect;
    data['marks'] = this.marks;
    return data;
  }
}

export interface IOptionDto {
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;
}

export class OptionResDetailDto implements IOptionResDetailDto {
  userAnswerOptionOptions?: UserAnswerOptionResDto[] | undefined;
  optionQuestionIdfk?: QuestionResDto;
  optionId?: number;
  questionId?: number;
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;

  constructor(data?: IOptionResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['userAnswerOptionOptions'])) {
        this.userAnswerOptionOptions = [] as any;
        for (let item of _data['userAnswerOptionOptions'])
          this.userAnswerOptionOptions!.push(UserAnswerOptionResDto.fromJS(item));
      }
      this.optionQuestionIdfk = _data['optionQuestionIdfk']
        ? QuestionResDto.fromJS(_data['optionQuestionIdfk'])
        : <any>undefined;
      this.optionId = _data['optionId'];
      this.questionId = _data['questionId'];
      this.optionText = _data['optionText'];
      this.isCorrect = _data['isCorrect'];
      this.marks = _data['marks'];
    }
  }

  static fromJS(data: any): OptionResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new OptionResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.userAnswerOptionOptions)) {
      data['userAnswerOptionOptions'] = [];
      for (let item of this.userAnswerOptionOptions)
        data['userAnswerOptionOptions'].push(item.toJSON());
    }
    data['optionQuestionIdfk'] = this.optionQuestionIdfk
      ? this.optionQuestionIdfk.toJSON()
      : <any>undefined;
    data['optionId'] = this.optionId;
    data['questionId'] = this.questionId;
    data['optionText'] = this.optionText;
    data['isCorrect'] = this.isCorrect;
    data['marks'] = this.marks;
    return data;
  }
}

export interface IOptionResDetailDto {
  userAnswerOptionOptions?: UserAnswerOptionResDto[] | undefined;
  optionQuestionIdfk?: QuestionResDto;
  optionId?: number;
  questionId?: number;
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;
}

export class OptionResDetailDtoSingleResponse implements IOptionResDetailDtoSingleResponse {
  data?: OptionResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IOptionResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? OptionResDetailDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OptionResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new OptionResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOptionResDetailDtoSingleResponse {
  data?: OptionResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class OptionResDto implements IOptionResDto {
  optionId?: number;
  questionId?: number;
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;

  constructor(data?: IOptionResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.optionId = _data['optionId'];
      this.questionId = _data['questionId'];
      this.optionText = _data['optionText'];
      this.isCorrect = _data['isCorrect'];
      this.marks = _data['marks'];
    }
  }

  static fromJS(data: any): OptionResDto {
    data = typeof data === 'object' ? data : {};
    let result = new OptionResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['optionId'] = this.optionId;
    data['questionId'] = this.questionId;
    data['optionText'] = this.optionText;
    data['isCorrect'] = this.isCorrect;
    data['marks'] = this.marks;
    return data;
  }
}

export interface IOptionResDto {
  optionId?: number;
  questionId?: number;
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;
}

export class OptionResDtoListResponse implements IOptionResDtoListResponse {
  data?: OptionResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IOptionResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(OptionResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OptionResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new OptionResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOptionResDtoListResponse {
  data?: OptionResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class OptionResDtoSingleResponse implements IOptionResDtoSingleResponse {
  data?: OptionResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IOptionResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? OptionResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OptionResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new OptionResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IOptionResDtoSingleResponse {
  data?: OptionResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class PageDetails implements IPageDetails {
  readonly pageNumber?: number;
  pageSize?: number;
  readonly totalPages?: number;
  totalCount?: number;
  readonly hasPreviousPage?: boolean;
  readonly hasNextPage?: boolean;

  constructor(data?: IPageDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).pageNumber = _data['pageNumber'];
      this.pageSize = _data['pageSize'];
      (<any>this).totalPages = _data['totalPages'];
      this.totalCount = _data['totalCount'];
      (<any>this).hasPreviousPage = _data['hasPreviousPage'];
      (<any>this).hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PageDetails {
    data = typeof data === 'object' ? data : {};
    let result = new PageDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageNumber'] = this.pageNumber;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['totalCount'] = this.totalCount;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPageDetails {
  pageNumber?: number;
  pageSize?: number;
  totalPages?: number;
  totalCount?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class Pagination implements IPagination {
  pageNum?: number;
  pageSize?: number;
  sortBy?: string | undefined;
  sortDescending?: boolean;

  constructor(data?: IPagination) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageNum = _data['pageNum'];
      this.pageSize = _data['pageSize'];
      this.sortBy = _data['sortBy'];
      this.sortDescending = _data['sortDescending'];
    }
  }

  static fromJS(data: any): Pagination {
    data = typeof data === 'object' ? data : {};
    let result = new Pagination();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageNum'] = this.pageNum;
    data['pageSize'] = this.pageSize;
    data['sortBy'] = this.sortBy;
    data['sortDescending'] = this.sortDescending;
    return data;
  }
}

export interface IPagination {
  pageNum?: number;
  pageSize?: number;
  sortBy?: string | undefined;
  sortDescending?: boolean;
}

export class QuestionDto implements IQuestionDto {
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  options?: OptionDto[] | undefined;

  constructor(data?: IQuestionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionId = _data['sectionId'];
      this.questionText = _data['questionText'];
      this.isMedia = _data['isMedia'];
      this.mediaType = _data['mediaType'];
      this.mediaURL = _data['mediaURL'];
      this.isMultipleChoice = _data['isMultipleChoice'];
      this.isFromQuestionBank = _data['isFromQuestionBank'];
      this.questionMaxMarks = _data['questionMaxMarks'];
      this.createdBy = _data['createdBy'];
      if (Array.isArray(_data['options'])) {
        this.options = [] as any;
        for (let item of _data['options']) this.options!.push(OptionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): QuestionDto {
    data = typeof data === 'object' ? data : {};
    let result = new QuestionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionId'] = this.sectionId;
    data['questionText'] = this.questionText;
    data['isMedia'] = this.isMedia;
    data['mediaType'] = this.mediaType;
    data['mediaURL'] = this.mediaURL;
    data['isMultipleChoice'] = this.isMultipleChoice;
    data['isFromQuestionBank'] = this.isFromQuestionBank;
    data['questionMaxMarks'] = this.questionMaxMarks;
    data['createdBy'] = this.createdBy;
    if (Array.isArray(this.options)) {
      data['options'] = [];
      for (let item of this.options) data['options'].push(item.toJSON());
    }
    return data;
  }
}

export interface IQuestionDto {
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  options?: OptionDto[] | undefined;
}

export class QuestionDtoSingleResponse implements IQuestionDtoSingleResponse {
  data?: QuestionDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IQuestionDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? QuestionDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): QuestionDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new QuestionDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IQuestionDtoSingleResponse {
  data?: QuestionDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class QuestionResDetailDto implements IQuestionResDetailDto {
  optionQuestions?: OptionResDto[] | undefined;
  userAnswerQuestions?: UserAnswerResDto[] | undefined;
  questionSectionIdfk?: SectionResDto;
  questionId?: number;
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IQuestionResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['optionQuestions'])) {
        this.optionQuestions = [] as any;
        for (let item of _data['optionQuestions'])
          this.optionQuestions!.push(OptionResDto.fromJS(item));
      }
      if (Array.isArray(_data['userAnswerQuestions'])) {
        this.userAnswerQuestions = [] as any;
        for (let item of _data['userAnswerQuestions'])
          this.userAnswerQuestions!.push(UserAnswerResDto.fromJS(item));
      }
      this.questionSectionIdfk = _data['questionSectionIdfk']
        ? SectionResDto.fromJS(_data['questionSectionIdfk'])
        : <any>undefined;
      this.questionId = _data['questionId'];
      this.sectionId = _data['sectionId'];
      this.questionText = _data['questionText'];
      this.isMedia = _data['isMedia'];
      this.mediaType = _data['mediaType'];
      this.mediaURL = _data['mediaURL'];
      this.isMultipleChoice = _data['isMultipleChoice'];
      this.isFromQuestionBank = _data['isFromQuestionBank'];
      this.questionMaxMarks = _data['questionMaxMarks'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): QuestionResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new QuestionResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.optionQuestions)) {
      data['optionQuestions'] = [];
      for (let item of this.optionQuestions) data['optionQuestions'].push(item.toJSON());
    }
    if (Array.isArray(this.userAnswerQuestions)) {
      data['userAnswerQuestions'] = [];
      for (let item of this.userAnswerQuestions) data['userAnswerQuestions'].push(item.toJSON());
    }
    data['questionSectionIdfk'] = this.questionSectionIdfk
      ? this.questionSectionIdfk.toJSON()
      : <any>undefined;
    data['questionId'] = this.questionId;
    data['sectionId'] = this.sectionId;
    data['questionText'] = this.questionText;
    data['isMedia'] = this.isMedia;
    data['mediaType'] = this.mediaType;
    data['mediaURL'] = this.mediaURL;
    data['isMultipleChoice'] = this.isMultipleChoice;
    data['isFromQuestionBank'] = this.isFromQuestionBank;
    data['questionMaxMarks'] = this.questionMaxMarks;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IQuestionResDetailDto {
  optionQuestions?: OptionResDto[] | undefined;
  userAnswerQuestions?: UserAnswerResDto[] | undefined;
  questionSectionIdfk?: SectionResDto;
  questionId?: number;
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class QuestionResDetailDtoSingleResponse implements IQuestionResDetailDtoSingleResponse {
  data?: QuestionResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IQuestionResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? QuestionResDetailDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): QuestionResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new QuestionResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IQuestionResDetailDtoSingleResponse {
  data?: QuestionResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class QuestionResDto implements IQuestionResDto {
  questionId?: number;
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IQuestionResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId'];
      this.sectionId = _data['sectionId'];
      this.questionText = _data['questionText'];
      this.isMedia = _data['isMedia'];
      this.mediaType = _data['mediaType'];
      this.mediaURL = _data['mediaURL'];
      this.isMultipleChoice = _data['isMultipleChoice'];
      this.isFromQuestionBank = _data['isFromQuestionBank'];
      this.questionMaxMarks = _data['questionMaxMarks'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): QuestionResDto {
    data = typeof data === 'object' ? data : {};
    let result = new QuestionResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['questionId'] = this.questionId;
    data['sectionId'] = this.sectionId;
    data['questionText'] = this.questionText;
    data['isMedia'] = this.isMedia;
    data['mediaType'] = this.mediaType;
    data['mediaURL'] = this.mediaURL;
    data['isMultipleChoice'] = this.isMultipleChoice;
    data['isFromQuestionBank'] = this.isFromQuestionBank;
    data['questionMaxMarks'] = this.questionMaxMarks;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IQuestionResDto {
  questionId?: number;
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class QuestionResDtoListResponse implements IQuestionResDtoListResponse {
  data?: QuestionResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IQuestionResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(QuestionResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): QuestionResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new QuestionResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IQuestionResDtoListResponse {
  data?: QuestionResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class QuestionResDtoSingleResponse implements IQuestionResDtoSingleResponse {
  data?: QuestionResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IQuestionResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? QuestionResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): QuestionResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new QuestionResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IQuestionResDtoSingleResponse {
  data?: QuestionResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class RegisterDto implements IRegisterDto {
  firstname!: string;
  lastname!: string;
  password!: string;
  email!: string;
  mobileNo!: string;
  role!: string;

  constructor(data?: IRegisterDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstname = _data['firstname'];
      this.lastname = _data['lastname'];
      this.password = _data['password'];
      this.email = _data['email'];
      this.mobileNo = _data['mobileNo'];
      this.role = _data['role'];
    }
  }

  static fromJS(data: any): RegisterDto {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['firstname'] = this.firstname;
    data['lastname'] = this.lastname;
    data['password'] = this.password;
    data['email'] = this.email;
    data['mobileNo'] = this.mobileNo;
    data['role'] = this.role;
    return data;
  }
}

export interface IRegisterDto {
  firstname: string;
  lastname: string;
  password: string;
  email: string;
  mobileNo: string;
  role: string;
}

export class ResponseMessage implements IResponseMessage {
  message?: string | undefined;
  description?: string | undefined;

  constructor(data?: IResponseMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.message = _data['message'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): ResponseMessage {
    data = typeof data === 'object' ? data : {};
    let result = new ResponseMessage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['message'] = this.message;
    data['description'] = this.description;
    return data;
  }
}

export interface IResponseMessage {
  message?: string | undefined;
  description?: string | undefined;
}

export class SectionResDetailDto implements ISectionResDetailDto {
  questionSections?: QuestionResDto[] | undefined;
  sectionResultSections?: SectionResultResDto[] | undefined;
  userAnswerSections?: UserAnswerResDto[] | undefined;
  sectionExamIdfk?: ExamResDto;
  sectionId?: number;
  examId?: number;
  title?: string | undefined;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  weightagePercentage?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: ISectionResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['questionSections'])) {
        this.questionSections = [] as any;
        for (let item of _data['questionSections'])
          this.questionSections!.push(QuestionResDto.fromJS(item));
      }
      if (Array.isArray(_data['sectionResultSections'])) {
        this.sectionResultSections = [] as any;
        for (let item of _data['sectionResultSections'])
          this.sectionResultSections!.push(SectionResultResDto.fromJS(item));
      }
      if (Array.isArray(_data['userAnswerSections'])) {
        this.userAnswerSections = [] as any;
        for (let item of _data['userAnswerSections'])
          this.userAnswerSections!.push(UserAnswerResDto.fromJS(item));
      }
      this.sectionExamIdfk = _data['sectionExamIdfk']
        ? ExamResDto.fromJS(_data['sectionExamIdfk'])
        : <any>undefined;
      this.sectionId = _data['sectionId'];
      this.examId = _data['examId'];
      this.title = _data['title'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.weightagePercentage = _data['weightagePercentage'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): SectionResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.questionSections)) {
      data['questionSections'] = [];
      for (let item of this.questionSections) data['questionSections'].push(item.toJSON());
    }
    if (Array.isArray(this.sectionResultSections)) {
      data['sectionResultSections'] = [];
      for (let item of this.sectionResultSections)
        data['sectionResultSections'].push(item.toJSON());
    }
    if (Array.isArray(this.userAnswerSections)) {
      data['userAnswerSections'] = [];
      for (let item of this.userAnswerSections) data['userAnswerSections'].push(item.toJSON());
    }
    data['sectionExamIdfk'] = this.sectionExamIdfk ? this.sectionExamIdfk.toJSON() : <any>undefined;
    data['sectionId'] = this.sectionId;
    data['examId'] = this.examId;
    data['title'] = this.title;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['weightagePercentage'] = this.weightagePercentage;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface ISectionResDetailDto {
  questionSections?: QuestionResDto[] | undefined;
  sectionResultSections?: SectionResultResDto[] | undefined;
  userAnswerSections?: UserAnswerResDto[] | undefined;
  sectionExamIdfk?: ExamResDto;
  sectionId?: number;
  examId?: number;
  title?: string | undefined;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  weightagePercentage?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class SectionResDetailDtoSingleResponse implements ISectionResDetailDtoSingleResponse {
  data?: SectionResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: ISectionResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? SectionResDetailDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SectionResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISectionResDetailDtoSingleResponse {
  data?: SectionResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class SectionResDto implements ISectionResDto {
  sectionId?: number;
  examId?: number;
  title?: string | undefined;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  weightagePercentage?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: ISectionResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionId = _data['sectionId'];
      this.examId = _data['examId'];
      this.title = _data['title'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.weightagePercentage = _data['weightagePercentage'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): SectionResDto {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionId'] = this.sectionId;
    data['examId'] = this.examId;
    data['title'] = this.title;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['weightagePercentage'] = this.weightagePercentage;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface ISectionResDto {
  sectionId?: number;
  examId?: number;
  title?: string | undefined;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  weightagePercentage?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class SectionResDtoListResponse implements ISectionResDtoListResponse {
  data?: SectionResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: ISectionResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(SectionResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SectionResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISectionResDtoListResponse {
  data?: SectionResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class SectionResDtoSingleResponse implements ISectionResDtoSingleResponse {
  data?: SectionResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: ISectionResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? SectionResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SectionResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISectionResDtoSingleResponse {
  data?: SectionResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class SectionResultResDetailDto implements ISectionResultResDetailDto {
  sectionResultSectionIdfk?: SectionResDto;
  sectionResultUserExamIdfk?: UserExamResDto;
  sectionResultId?: number;
  sectionId?: number;
  userExamId?: number;
  questionsAttempted?: number;
  marksObtained?: number;
  resultStatus?: string | undefined;

  constructor(data?: ISectionResultResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionResultSectionIdfk = _data['sectionResultSectionIdfk']
        ? SectionResDto.fromJS(_data['sectionResultSectionIdfk'])
        : <any>undefined;
      this.sectionResultUserExamIdfk = _data['sectionResultUserExamIdfk']
        ? UserExamResDto.fromJS(_data['sectionResultUserExamIdfk'])
        : <any>undefined;
      this.sectionResultId = _data['sectionResultId'];
      this.sectionId = _data['sectionId'];
      this.userExamId = _data['userExamId'];
      this.questionsAttempted = _data['questionsAttempted'];
      this.marksObtained = _data['marksObtained'];
      this.resultStatus = _data['resultStatus'];
    }
  }

  static fromJS(data: any): SectionResultResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResultResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionResultSectionIdfk'] = this.sectionResultSectionIdfk
      ? this.sectionResultSectionIdfk.toJSON()
      : <any>undefined;
    data['sectionResultUserExamIdfk'] = this.sectionResultUserExamIdfk
      ? this.sectionResultUserExamIdfk.toJSON()
      : <any>undefined;
    data['sectionResultId'] = this.sectionResultId;
    data['sectionId'] = this.sectionId;
    data['userExamId'] = this.userExamId;
    data['questionsAttempted'] = this.questionsAttempted;
    data['marksObtained'] = this.marksObtained;
    data['resultStatus'] = this.resultStatus;
    return data;
  }
}

export interface ISectionResultResDetailDto {
  sectionResultSectionIdfk?: SectionResDto;
  sectionResultUserExamIdfk?: UserExamResDto;
  sectionResultId?: number;
  sectionId?: number;
  userExamId?: number;
  questionsAttempted?: number;
  marksObtained?: number;
  resultStatus?: string | undefined;
}

export class SectionResultResDetailDtoSingleResponse
  implements ISectionResultResDetailDtoSingleResponse
{
  data?: SectionResultResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: ISectionResultResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? SectionResultResDetailDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SectionResultResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResultResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISectionResultResDetailDtoSingleResponse {
  data?: SectionResultResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class SectionResultResDto implements ISectionResultResDto {
  sectionResultId?: number;
  sectionId?: number;
  userExamId?: number;
  questionsAttempted?: number;
  marksObtained?: number;
  resultStatus?: string | undefined;

  constructor(data?: ISectionResultResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionResultId = _data['sectionResultId'];
      this.sectionId = _data['sectionId'];
      this.userExamId = _data['userExamId'];
      this.questionsAttempted = _data['questionsAttempted'];
      this.marksObtained = _data['marksObtained'];
      this.resultStatus = _data['resultStatus'];
    }
  }

  static fromJS(data: any): SectionResultResDto {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResultResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionResultId'] = this.sectionResultId;
    data['sectionId'] = this.sectionId;
    data['userExamId'] = this.userExamId;
    data['questionsAttempted'] = this.questionsAttempted;
    data['marksObtained'] = this.marksObtained;
    data['resultStatus'] = this.resultStatus;
    return data;
  }
}

export interface ISectionResultResDto {
  sectionResultId?: number;
  sectionId?: number;
  userExamId?: number;
  questionsAttempted?: number;
  marksObtained?: number;
  resultStatus?: string | undefined;
}

export class SectionResultResDtoListResponse implements ISectionResultResDtoListResponse {
  data?: SectionResultResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: ISectionResultResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(SectionResultResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SectionResultResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResultResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISectionResultResDtoListResponse {
  data?: SectionResultResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class SectionResultResDtoSingleResponse implements ISectionResultResDtoSingleResponse {
  data?: SectionResultResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: ISectionResultResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? SectionResultResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SectionResultResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SectionResultResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISectionResultResDtoSingleResponse {
  data?: SectionResultResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class StringFilterExpression implements IStringFilterExpression {
  combineWith?: LogicalOperator;
  filters?: StringFilterOption[] | undefined;

  constructor(data?: IStringFilterExpression) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.combineWith = _data['combineWith'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters']) this.filters!.push(StringFilterOption.fromJS(item));
      }
    }
  }

  static fromJS(data: any): StringFilterExpression {
    data = typeof data === 'object' ? data : {};
    let result = new StringFilterExpression();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['combineWith'] = this.combineWith;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters) data['filters'].push(item.toJSON());
    }
    return data;
  }
}

export interface IStringFilterExpression {
  combineWith?: LogicalOperator;
  filters?: StringFilterOption[] | undefined;
}

export class StringFilterOption implements IStringFilterOption {
  value?: string | undefined;
  comparisonOperator?: ComparisonOperator;

  constructor(data?: IStringFilterOption) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.value = _data['value'];
      this.comparisonOperator = _data['comparisonOperator'];
    }
  }

  static fromJS(data: any): StringFilterOption {
    data = typeof data === 'object' ? data : {};
    let result = new StringFilterOption();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['value'] = this.value;
    data['comparisonOperator'] = this.comparisonOperator;
    return data;
  }
}

export interface IStringFilterOption {
  value?: string | undefined;
  comparisonOperator?: ComparisonOperator;
}

export class UpdateApplicationUserReqDto implements IUpdateApplicationUserReqDto {
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;

  constructor(data?: IUpdateApplicationUserReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.userName = _data['userName'];
      this.normalizedUserName = _data['normalizedUserName'];
      this.email = _data['email'];
      this.normalizedEmail = _data['normalizedEmail'];
      this.emailConfirmed = _data['emailConfirmed'];
      this.passwordHash = _data['passwordHash'];
      this.securityStamp = _data['securityStamp'];
      this.concurrencyStamp = _data['concurrencyStamp'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumberConfirmed = _data['phoneNumberConfirmed'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      this.lockoutEnd = _data['lockoutEnd']
        ? new Date(_data['lockoutEnd'].toString())
        : <any>undefined;
      this.lockoutEnabled = _data['lockoutEnabled'];
      this.accessFailedCount = _data['accessFailedCount'];
    }
  }

  static fromJS(data: any): UpdateApplicationUserReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateApplicationUserReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['userName'] = this.userName;
    data['normalizedUserName'] = this.normalizedUserName;
    data['email'] = this.email;
    data['normalizedEmail'] = this.normalizedEmail;
    data['emailConfirmed'] = this.emailConfirmed;
    data['passwordHash'] = this.passwordHash;
    data['securityStamp'] = this.securityStamp;
    data['concurrencyStamp'] = this.concurrencyStamp;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumberConfirmed'] = this.phoneNumberConfirmed;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    data['lockoutEnd'] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data['lockoutEnabled'] = this.lockoutEnabled;
    data['accessFailedCount'] = this.accessFailedCount;
    return data;
  }
}

export interface IUpdateApplicationUserReqDto {
  id?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean;
  twoFactorEnabled?: boolean;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean;
  accessFailedCount?: number;
}

export class UpdateExamReqDto implements IUpdateExamReqDto {
  examId?: number;
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IUpdateExamReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examId = _data['examId'];
      this.title = _data['title'];
      this.description = _data['description'];
      this.startDate = _data['startDate']
        ? new Date(_data['startDate'].toString())
        : <any>undefined;
      this.endDate = _data['endDate'] ? new Date(_data['endDate'].toString()) : <any>undefined;
      this.duration = _data['duration'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.isRandomized = _data['isRandomized'];
      this.isActive = _data['isActive'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateExamReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateExamReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examId'] = this.examId;
    data['title'] = this.title;
    data['description'] = this.description;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['endDate'] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data['duration'] = this.duration;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['isRandomized'] = this.isRandomized;
    data['isActive'] = this.isActive;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUpdateExamReqDto {
  examId?: number;
  title?: string | undefined;
  description?: string | undefined;
  startDate?: Date;
  endDate?: Date;
  duration?: number;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  isRandomized?: boolean;
  isActive?: boolean;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class UpdateExamResultReqDto implements IUpdateExamResultReqDto {
  examResultId?: number;
  userExamId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IUpdateExamResultReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.examResultId = _data['examResultId'];
      this.userExamId = _data['userExamId'];
      this.totalObtainedMarks = _data['totalObtainedMarks'];
      this.resultStatus = _data['resultStatus'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateExamResultReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateExamResultReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['examResultId'] = this.examResultId;
    data['userExamId'] = this.userExamId;
    data['totalObtainedMarks'] = this.totalObtainedMarks;
    data['resultStatus'] = this.resultStatus;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUpdateExamResultReqDto {
  examResultId?: number;
  userExamId?: number;
  totalObtainedMarks?: number;
  resultStatus?: string | undefined;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class UpdateOptionReqDto implements IUpdateOptionReqDto {
  optionId?: number;
  questionId?: number;
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;

  constructor(data?: IUpdateOptionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.optionId = _data['optionId'];
      this.questionId = _data['questionId'];
      this.optionText = _data['optionText'];
      this.isCorrect = _data['isCorrect'];
      this.marks = _data['marks'];
    }
  }

  static fromJS(data: any): UpdateOptionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateOptionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['optionId'] = this.optionId;
    data['questionId'] = this.questionId;
    data['optionText'] = this.optionText;
    data['isCorrect'] = this.isCorrect;
    data['marks'] = this.marks;
    return data;
  }
}

export interface IUpdateOptionReqDto {
  optionId?: number;
  questionId?: number;
  optionText?: string | undefined;
  isCorrect?: boolean;
  marks?: number;
}

export class UpdateQuestionReqDto implements IUpdateQuestionReqDto {
  questionId?: number;
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IUpdateQuestionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId'];
      this.sectionId = _data['sectionId'];
      this.questionText = _data['questionText'];
      this.isMedia = _data['isMedia'];
      this.mediaType = _data['mediaType'];
      this.mediaURL = _data['mediaURL'];
      this.isMultipleChoice = _data['isMultipleChoice'];
      this.isFromQuestionBank = _data['isFromQuestionBank'];
      this.questionMaxMarks = _data['questionMaxMarks'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateQuestionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateQuestionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['questionId'] = this.questionId;
    data['sectionId'] = this.sectionId;
    data['questionText'] = this.questionText;
    data['isMedia'] = this.isMedia;
    data['mediaType'] = this.mediaType;
    data['mediaURL'] = this.mediaURL;
    data['isMultipleChoice'] = this.isMultipleChoice;
    data['isFromQuestionBank'] = this.isFromQuestionBank;
    data['questionMaxMarks'] = this.questionMaxMarks;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUpdateQuestionReqDto {
  questionId?: number;
  sectionId?: number;
  questionText?: string | undefined;
  isMedia?: boolean;
  mediaType?: string | undefined;
  mediaURL?: string | undefined;
  isMultipleChoice?: boolean;
  isFromQuestionBank?: boolean;
  questionMaxMarks?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class UpdateSectionReqDto implements IUpdateSectionReqDto {
  sectionId?: number;
  examId?: number;
  title?: string | undefined;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  weightagePercentage?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IUpdateSectionReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionId = _data['sectionId'];
      this.examId = _data['examId'];
      this.title = _data['title'];
      this.totalQuestions = _data['totalQuestions'];
      this.totalMarks = _data['totalMarks'];
      this.passingMarks = _data['passingMarks'];
      this.weightagePercentage = _data['weightagePercentage'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateSectionReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateSectionReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionId'] = this.sectionId;
    data['examId'] = this.examId;
    data['title'] = this.title;
    data['totalQuestions'] = this.totalQuestions;
    data['totalMarks'] = this.totalMarks;
    data['passingMarks'] = this.passingMarks;
    data['weightagePercentage'] = this.weightagePercentage;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUpdateSectionReqDto {
  sectionId?: number;
  examId?: number;
  title?: string | undefined;
  totalQuestions?: number;
  totalMarks?: number;
  passingMarks?: number;
  weightagePercentage?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class UpdateSectionResultReqDto implements IUpdateSectionResultReqDto {
  sectionResultId?: number;
  sectionId?: number;
  userExamId?: number;
  questionsAttempted?: number;
  marksObtained?: number;
  resultStatus?: string | undefined;

  constructor(data?: IUpdateSectionResultReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sectionResultId = _data['sectionResultId'];
      this.sectionId = _data['sectionId'];
      this.userExamId = _data['userExamId'];
      this.questionsAttempted = _data['questionsAttempted'];
      this.marksObtained = _data['marksObtained'];
      this.resultStatus = _data['resultStatus'];
    }
  }

  static fromJS(data: any): UpdateSectionResultReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateSectionResultReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sectionResultId'] = this.sectionResultId;
    data['sectionId'] = this.sectionId;
    data['userExamId'] = this.userExamId;
    data['questionsAttempted'] = this.questionsAttempted;
    data['marksObtained'] = this.marksObtained;
    data['resultStatus'] = this.resultStatus;
    return data;
  }
}

export interface IUpdateSectionResultReqDto {
  sectionResultId?: number;
  sectionId?: number;
  userExamId?: number;
  questionsAttempted?: number;
  marksObtained?: number;
  resultStatus?: string | undefined;
}

export class UpdateUserAnswerReqDto implements IUpdateUserAnswerReqDto {
  userAnswerId?: number;
  questionId?: number;
  userExamId?: number;
  sectionId?: number;

  constructor(data?: IUpdateUserAnswerReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userAnswerId = _data['userAnswerId'];
      this.questionId = _data['questionId'];
      this.userExamId = _data['userExamId'];
      this.sectionId = _data['sectionId'];
    }
  }

  static fromJS(data: any): UpdateUserAnswerReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserAnswerReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userAnswerId'] = this.userAnswerId;
    data['questionId'] = this.questionId;
    data['userExamId'] = this.userExamId;
    data['sectionId'] = this.sectionId;
    return data;
  }
}

export interface IUpdateUserAnswerReqDto {
  userAnswerId?: number;
  questionId?: number;
  userExamId?: number;
  sectionId?: number;
}

export class UpdateUserExamReqDto implements IUpdateUserExamReqDto {
  userExamId?: number;
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IUpdateUserExamReqDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userExamId = _data['userExamId'];
      this.userId = _data['userId'];
      this.examId = _data['examId'];
      this.startedOn = _data['startedOn']
        ? new Date(_data['startedOn'].toString())
        : <any>undefined;
      this.finishedOn = _data['finishedOn']
        ? new Date(_data['finishedOn'].toString())
        : <any>undefined;
      this.examStatus = _data['examStatus'];
      this.totalMarks = _data['totalMarks'];
      this.isAutoSubmitted = _data['isAutoSubmitted'];
      this.noOfAttempt = _data['noOfAttempt'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): UpdateUserExamReqDto {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserExamReqDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userExamId'] = this.userExamId;
    data['userId'] = this.userId;
    data['examId'] = this.examId;
    data['startedOn'] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
    data['finishedOn'] = this.finishedOn ? this.finishedOn.toISOString() : <any>undefined;
    data['examStatus'] = this.examStatus;
    data['totalMarks'] = this.totalMarks;
    data['isAutoSubmitted'] = this.isAutoSubmitted;
    data['noOfAttempt'] = this.noOfAttempt;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUpdateUserExamReqDto {
  userExamId?: number;
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class UserAnswerOptionResDto implements IUserAnswerOptionResDto {
  userAnswerId?: number;
  optionId?: number;

  constructor(data?: IUserAnswerOptionResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userAnswerId = _data['userAnswerId'];
      this.optionId = _data['optionId'];
    }
  }

  static fromJS(data: any): UserAnswerOptionResDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserAnswerOptionResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userAnswerId'] = this.userAnswerId;
    data['optionId'] = this.optionId;
    return data;
  }
}

export interface IUserAnswerOptionResDto {
  userAnswerId?: number;
  optionId?: number;
}

export class UserAnswerResDetailDto implements IUserAnswerResDetailDto {
  userAnswerOptionUserAnswers?: UserAnswerOptionResDto[] | undefined;
  userAnswerQuestionIdfk?: QuestionResDto;
  userAnswerUserExamIdfk?: UserExamResDto;
  userAnswerSectionIdfk?: SectionResDto;
  userAnswerId?: number;
  questionId?: number;
  userExamId?: number;
  sectionId?: number;

  constructor(data?: IUserAnswerResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['userAnswerOptionUserAnswers'])) {
        this.userAnswerOptionUserAnswers = [] as any;
        for (let item of _data['userAnswerOptionUserAnswers'])
          this.userAnswerOptionUserAnswers!.push(UserAnswerOptionResDto.fromJS(item));
      }
      this.userAnswerQuestionIdfk = _data['userAnswerQuestionIdfk']
        ? QuestionResDto.fromJS(_data['userAnswerQuestionIdfk'])
        : <any>undefined;
      this.userAnswerUserExamIdfk = _data['userAnswerUserExamIdfk']
        ? UserExamResDto.fromJS(_data['userAnswerUserExamIdfk'])
        : <any>undefined;
      this.userAnswerSectionIdfk = _data['userAnswerSectionIdfk']
        ? SectionResDto.fromJS(_data['userAnswerSectionIdfk'])
        : <any>undefined;
      this.userAnswerId = _data['userAnswerId'];
      this.questionId = _data['questionId'];
      this.userExamId = _data['userExamId'];
      this.sectionId = _data['sectionId'];
    }
  }

  static fromJS(data: any): UserAnswerResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserAnswerResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.userAnswerOptionUserAnswers)) {
      data['userAnswerOptionUserAnswers'] = [];
      for (let item of this.userAnswerOptionUserAnswers)
        data['userAnswerOptionUserAnswers'].push(item.toJSON());
    }
    data['userAnswerQuestionIdfk'] = this.userAnswerQuestionIdfk
      ? this.userAnswerQuestionIdfk.toJSON()
      : <any>undefined;
    data['userAnswerUserExamIdfk'] = this.userAnswerUserExamIdfk
      ? this.userAnswerUserExamIdfk.toJSON()
      : <any>undefined;
    data['userAnswerSectionIdfk'] = this.userAnswerSectionIdfk
      ? this.userAnswerSectionIdfk.toJSON()
      : <any>undefined;
    data['userAnswerId'] = this.userAnswerId;
    data['questionId'] = this.questionId;
    data['userExamId'] = this.userExamId;
    data['sectionId'] = this.sectionId;
    return data;
  }
}

export interface IUserAnswerResDetailDto {
  userAnswerOptionUserAnswers?: UserAnswerOptionResDto[] | undefined;
  userAnswerQuestionIdfk?: QuestionResDto;
  userAnswerUserExamIdfk?: UserExamResDto;
  userAnswerSectionIdfk?: SectionResDto;
  userAnswerId?: number;
  questionId?: number;
  userExamId?: number;
  sectionId?: number;
}

export class UserAnswerResDetailDtoSingleResponse implements IUserAnswerResDetailDtoSingleResponse {
  data?: UserAnswerResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IUserAnswerResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? UserAnswerResDetailDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserAnswerResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserAnswerResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserAnswerResDetailDtoSingleResponse {
  data?: UserAnswerResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class UserAnswerResDto implements IUserAnswerResDto {
  userAnswerId?: number;
  questionId?: number;
  userExamId?: number;
  sectionId?: number;

  constructor(data?: IUserAnswerResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userAnswerId = _data['userAnswerId'];
      this.questionId = _data['questionId'];
      this.userExamId = _data['userExamId'];
      this.sectionId = _data['sectionId'];
    }
  }

  static fromJS(data: any): UserAnswerResDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserAnswerResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userAnswerId'] = this.userAnswerId;
    data['questionId'] = this.questionId;
    data['userExamId'] = this.userExamId;
    data['sectionId'] = this.sectionId;
    return data;
  }
}

export interface IUserAnswerResDto {
  userAnswerId?: number;
  questionId?: number;
  userExamId?: number;
  sectionId?: number;
}

export class UserAnswerResDtoListResponse implements IUserAnswerResDtoListResponse {
  data?: UserAnswerResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IUserAnswerResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(UserAnswerResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserAnswerResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserAnswerResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserAnswerResDtoListResponse {
  data?: UserAnswerResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class UserAnswerResDtoSingleResponse implements IUserAnswerResDtoSingleResponse {
  data?: UserAnswerResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IUserAnswerResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? UserAnswerResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserAnswerResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserAnswerResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserAnswerResDtoSingleResponse {
  data?: UserAnswerResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class UserExamResDetailDto implements IUserExamResDetailDto {
  examResultUserExams?: ExamResultResDto[] | undefined;
  sectionResultUserExams?: SectionResultResDto[] | undefined;
  userAnswerUserExams?: UserAnswerResDto[] | undefined;
  userExamUserIdfk?: ApplicationUserResDto;
  userExamExamIdfk?: ExamResDto;
  userExamId?: number;
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IUserExamResDetailDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['examResultUserExams'])) {
        this.examResultUserExams = [] as any;
        for (let item of _data['examResultUserExams'])
          this.examResultUserExams!.push(ExamResultResDto.fromJS(item));
      }
      if (Array.isArray(_data['sectionResultUserExams'])) {
        this.sectionResultUserExams = [] as any;
        for (let item of _data['sectionResultUserExams'])
          this.sectionResultUserExams!.push(SectionResultResDto.fromJS(item));
      }
      if (Array.isArray(_data['userAnswerUserExams'])) {
        this.userAnswerUserExams = [] as any;
        for (let item of _data['userAnswerUserExams'])
          this.userAnswerUserExams!.push(UserAnswerResDto.fromJS(item));
      }
      this.userExamUserIdfk = _data['userExamUserIdfk']
        ? ApplicationUserResDto.fromJS(_data['userExamUserIdfk'])
        : <any>undefined;
      this.userExamExamIdfk = _data['userExamExamIdfk']
        ? ExamResDto.fromJS(_data['userExamExamIdfk'])
        : <any>undefined;
      this.userExamId = _data['userExamId'];
      this.userId = _data['userId'];
      this.examId = _data['examId'];
      this.startedOn = _data['startedOn']
        ? new Date(_data['startedOn'].toString())
        : <any>undefined;
      this.finishedOn = _data['finishedOn']
        ? new Date(_data['finishedOn'].toString())
        : <any>undefined;
      this.examStatus = _data['examStatus'];
      this.totalMarks = _data['totalMarks'];
      this.isAutoSubmitted = _data['isAutoSubmitted'];
      this.noOfAttempt = _data['noOfAttempt'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): UserExamResDetailDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserExamResDetailDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.examResultUserExams)) {
      data['examResultUserExams'] = [];
      for (let item of this.examResultUserExams) data['examResultUserExams'].push(item.toJSON());
    }
    if (Array.isArray(this.sectionResultUserExams)) {
      data['sectionResultUserExams'] = [];
      for (let item of this.sectionResultUserExams)
        data['sectionResultUserExams'].push(item.toJSON());
    }
    if (Array.isArray(this.userAnswerUserExams)) {
      data['userAnswerUserExams'] = [];
      for (let item of this.userAnswerUserExams) data['userAnswerUserExams'].push(item.toJSON());
    }
    data['userExamUserIdfk'] = this.userExamUserIdfk
      ? this.userExamUserIdfk.toJSON()
      : <any>undefined;
    data['userExamExamIdfk'] = this.userExamExamIdfk
      ? this.userExamExamIdfk.toJSON()
      : <any>undefined;
    data['userExamId'] = this.userExamId;
    data['userId'] = this.userId;
    data['examId'] = this.examId;
    data['startedOn'] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
    data['finishedOn'] = this.finishedOn ? this.finishedOn.toISOString() : <any>undefined;
    data['examStatus'] = this.examStatus;
    data['totalMarks'] = this.totalMarks;
    data['isAutoSubmitted'] = this.isAutoSubmitted;
    data['noOfAttempt'] = this.noOfAttempt;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUserExamResDetailDto {
  examResultUserExams?: ExamResultResDto[] | undefined;
  sectionResultUserExams?: SectionResultResDto[] | undefined;
  userAnswerUserExams?: UserAnswerResDto[] | undefined;
  userExamUserIdfk?: ApplicationUserResDto;
  userExamExamIdfk?: ExamResDto;
  userExamId?: number;
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class UserExamResDetailDtoSingleResponse implements IUserExamResDetailDtoSingleResponse {
  data?: UserExamResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IUserExamResDetailDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? UserExamResDetailDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserExamResDetailDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserExamResDetailDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserExamResDetailDtoSingleResponse {
  data?: UserExamResDetailDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class UserExamResDto implements IUserExamResDto {
  userExamId?: number;
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;

  constructor(data?: IUserExamResDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userExamId = _data['userExamId'];
      this.userId = _data['userId'];
      this.examId = _data['examId'];
      this.startedOn = _data['startedOn']
        ? new Date(_data['startedOn'].toString())
        : <any>undefined;
      this.finishedOn = _data['finishedOn']
        ? new Date(_data['finishedOn'].toString())
        : <any>undefined;
      this.examStatus = _data['examStatus'];
      this.totalMarks = _data['totalMarks'];
      this.isAutoSubmitted = _data['isAutoSubmitted'];
      this.noOfAttempt = _data['noOfAttempt'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): UserExamResDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserExamResDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userExamId'] = this.userExamId;
    data['userId'] = this.userId;
    data['examId'] = this.examId;
    data['startedOn'] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
    data['finishedOn'] = this.finishedOn ? this.finishedOn.toISOString() : <any>undefined;
    data['examStatus'] = this.examStatus;
    data['totalMarks'] = this.totalMarks;
    data['isAutoSubmitted'] = this.isAutoSubmitted;
    data['noOfAttempt'] = this.noOfAttempt;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    return data;
  }
}

export interface IUserExamResDto {
  userExamId?: number;
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
}

export class UserExamResDtoListResponse implements IUserExamResDtoListResponse {
  data?: UserExamResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IUserExamResDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(UserExamResDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserExamResDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserExamResDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserExamResDtoListResponse {
  data?: UserExamResDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class UserExamResDtoSingleResponse implements IUserExamResDtoSingleResponse {
  data?: UserExamResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IUserExamResDtoSingleResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? UserExamResDto.fromJS(_data['data']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserExamResDtoSingleResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserExamResDtoSingleResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserExamResDtoSingleResponse {
  data?: UserExamResDto;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class UserExamWithResultDto implements IUserExamWithResultDto {
  userExamId?: number;
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
  examResult?: ExamResultDto;

  constructor(data?: IUserExamWithResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userExamId = _data['userExamId'];
      this.userId = _data['userId'];
      this.examId = _data['examId'];
      this.startedOn = _data['startedOn']
        ? new Date(_data['startedOn'].toString())
        : <any>undefined;
      this.finishedOn = _data['finishedOn']
        ? new Date(_data['finishedOn'].toString())
        : <any>undefined;
      this.examStatus = _data['examStatus'];
      this.totalMarks = _data['totalMarks'];
      this.isAutoSubmitted = _data['isAutoSubmitted'];
      this.noOfAttempt = _data['noOfAttempt'];
      this.createdBy = _data['createdBy'];
      this.createdOn = _data['createdOn']
        ? new Date(_data['createdOn'].toString())
        : <any>undefined;
      this.updatedOn = _data['updatedOn']
        ? new Date(_data['updatedOn'].toString())
        : <any>undefined;
      this.examResult = _data['examResult']
        ? ExamResultDto.fromJS(_data['examResult'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): UserExamWithResultDto {
    data = typeof data === 'object' ? data : {};
    let result = new UserExamWithResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userExamId'] = this.userExamId;
    data['userId'] = this.userId;
    data['examId'] = this.examId;
    data['startedOn'] = this.startedOn ? this.startedOn.toISOString() : <any>undefined;
    data['finishedOn'] = this.finishedOn ? this.finishedOn.toISOString() : <any>undefined;
    data['examStatus'] = this.examStatus;
    data['totalMarks'] = this.totalMarks;
    data['isAutoSubmitted'] = this.isAutoSubmitted;
    data['noOfAttempt'] = this.noOfAttempt;
    data['createdBy'] = this.createdBy;
    data['createdOn'] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
    data['updatedOn'] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
    data['examResult'] = this.examResult ? this.examResult.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUserExamWithResultDto {
  userExamId?: number;
  userId?: string | undefined;
  examId?: number;
  startedOn?: Date;
  finishedOn?: Date | undefined;
  examStatus?: string | undefined;
  totalMarks?: number | undefined;
  isAutoSubmitted?: boolean | undefined;
  noOfAttempt?: number;
  createdBy?: string | undefined;
  createdOn?: Date;
  updatedOn?: Date;
  examResult?: ExamResultDto;
}

export class UserExamWithResultDtoListResponse implements IUserExamWithResultDtoListResponse {
  data?: UserExamWithResultDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;

  constructor(data?: IUserExamWithResultDtoListResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(UserExamWithResultDto.fromJS(item));
      }
      this.pageInfo = _data['pageInfo'] ? PageDetails.fromJS(_data['pageInfo']) : <any>undefined;
      this.status = _data['status'];
      if (Array.isArray(_data['messages'])) {
        this.messages = [] as any;
        for (let item of _data['messages']) this.messages!.push(ResponseMessage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): UserExamWithResultDtoListResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserExamWithResultDtoListResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item.toJSON());
    }
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    data['status'] = this.status;
    if (Array.isArray(this.messages)) {
      data['messages'] = [];
      for (let item of this.messages) data['messages'].push(item.toJSON());
    }
    return data;
  }
}

export interface IUserExamWithResultDtoListResponse {
  data?: UserExamWithResultDto[] | undefined;
  pageInfo?: PageDetails;
  status?: HttpStatusCode;
  messages?: ResponseMessage[] | undefined;
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any,
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any,
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
